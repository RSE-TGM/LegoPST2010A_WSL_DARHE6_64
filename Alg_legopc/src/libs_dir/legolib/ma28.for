C******************************************************************************
C modulo ma28.f
C tipo 
C release 2.1
C data 7/10/95
C reserver @(#)ma28.f	2.1
C******************************************************************************
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                      C
C           LEGO unificato per singola / doppia precisione             C
C                 e per diverse piattaforme operative                  C
C                                                                      C
C   Attivata versione singola precisione per sistema operativo Unix    C
C                                                                      C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      SUBROUTINE ER28A(IFLAG)
      WRITE(6,999)IFLAG
      IF(IFLAG)1,100,50
    1 IFLAG=-IFLAG
      IF(IFLAG-7)10,5,2
    2 WRITE(6,1000)
 1000 FORMAT(//10X,'ERRORI NELLA MATRICE JACOBIANA DATA')
      GO TO 100
    5 WRITE(6,1001)
 1001 FORMAT(//10X,'ERRORE NELLA TRIANGOLARIZZAZIONE A BLOCCHI',
     $       /10X, 'DELLA MATRICE JACOBIANA')
      GO TO 100
C
   10 IF(IFLAG-2)30,20,15
   15 WRITE(6,1002)
 1002 FORMAT(//10X,'MEMORIA INSUFFICIENTE PER LA FATTORIZZAZIONE'
     $       /10X,'DELLA MATRICE JACOBIANA')
      GO TO 100
   20 WRITE(6,1003)
 1003 FORMAT(//10X,'MATRICE JACOBIANA NUMERICAMENTE SINGOLARE')
      IFLAG=0
      GO TO 100
   30 WRITE(6,1004)
 1004 FORMAT(//10X,'MATRICE JACOBIANA STRUTTURALMENTE SINGOLARE')
      IFLAG=0
      GO TO 100
   50 IF(IFLAG.LE.2)GO TO 10
      WRITE(6,1005)IFLAG
 1005 FORMAT(//10X,'ATTENZIONE - NELLA RIGA',I5,
     $   ' DELLA MATRICE JACOBIANA'/23X,' IL PIVOT EST MOLTO PICCOLO')
  999 FORMAT(/1X,'*********ERRORI NELLA FATTORIZZAZIONE DELLO JACOBIANO'
     $   /10X,'---IFLAG = ',I6,' ---')
  100 RETURN
      END
C
C
C
      SUBROUTINE MC20A (NC,MAXA,A,INUM,JPTR,JNUM,JDISP)
      DIMENSION INUM(MAXA),JNUM(MAXA),JPTR(NC),A(MAXA)
C
      NULL=-JDISP
C**      CLEAR JPTR
      DO 60 J=1,NC
   60 JPTR(J)=0
C**      COUNT THE NUMBER OF ELEMENTS IN EACH COLUMN.
      DO 120 K=1,MAXA
      J=JNUM(K)+JDISP
      JPTR(J)=JPTR(J)+1
  120 CONTINUE
C**      SET THE JPTR ARRAY
      K=1
      DO 150 J=1,NC
      KR=K+JPTR(J)
      JPTR(J)=K
  150 K=KR
C
C**      REORDER THE ELEMENTS INTO COLUMN ORDER.  THE ALGORITHM IS AN
C        IN-PLACE SORT AND IS OF ORDER MAXA.
      DO 230 I=1,MAXA
C        ESTABLISH THE CURRENT ENTRY.
      JCE=JNUM(I)+JDISP
      IF(JCE.EQ.0) GO TO 230
      ACE=A(I)
      ICE=INUM(I)
C        CLEAR THE LOCATION VACATED.
      JNUM(I)=NULL
C        CHAIN FROM CURRENT ENTRY TO STORE ITEMS.
      DO 200 J=1,MAXA
C        CURRENT ENTRY NOT IN CORRECT POSITION.  DETERMINE CORRECT
C        POSITION TO STORE ENTRY.
      LOC=JPTR(JCE)
      JPTR(JCE)=JPTR(JCE)+1
C        SAVE CONTENTS OF THAT LOCATION.
      ACEP=A(LOC)
      ICEP=INUM(LOC)
      JCEP=JNUM(LOC)
C        STORE CURRENT ENTRY.
      A(LOC)=ACE
      INUM(LOC)=ICE
      JNUM(LOC)=NULL
C        CHECK IF NEXT CURRENT ENTRY NEEDS TO BE PROCESSED.
      IF(JCEP.EQ.NULL) GO TO 230
C        IT DOES.  COPY INTO CURRENT ENTRY.
      ACE=ACEP
      ICE=ICEP
  200 JCE=JCEP+JDISP
C
  230 CONTINUE
C
C**      RESET JPTR VECTOR.
      JA=1
      DO 250 J=1,NC
      JB=JPTR(J)
      JPTR(J)=JA
  250 JA=JB
      RETURN
      END
C
C
C
      SUBROUTINE MC20B(NC,MAXA,A,INUM,JPTR)
      DIMENSION INUM(MAXA),JPTR(NC),A(MAXA)
C
      KMAX=MAXA
      DO 30 JJ=1,NC
      J=NC+1-JJ
      KLO=JPTR(J)+1
      IF(KLO.GT.KMAX)GO TO 30
      KOR=KMAX
      DO 25 KDUMMY=KLO,KMAX
C ITEMS KOR, KOR+1, .... ,KMAX ARE IN ORDER
      ACE=A(KOR-1)
      ICE=INUM(KOR-1)
      DO 10 K=KOR,KMAX
      IK=INUM(K)
      IF(IABS(ICE) .LE. IABS(IK))GO TO 20
      INUM(K-1)=IK
   10 A(K-1)=A(K)
      K=KMAX+1
   20 INUM(K-1)=ICE
      A(K-1)=ACE
   25 KOR=KOR-1
C        NEXT COLUMN
   30 KMAX=KLO-2
      RETURN
      END
C
C
C
      SUBROUTINE MC13D(N,ICN,LICN,IP,LENR,IOR,IB,NUM,IW)
      DIMENSION IP(N),ICN(LICN),LENR(N),IOR(N),IB(N),IW(N,3)
      CALL MC13E(N,ICN,LICN,IP,LENR,IOR,IB,NUM,IW(1,1),IW(1,2),IW(1,3))
      RETURN
      END
C
C
C
      SUBROUTINE MC13E(N,ICN,LICN,IP,LENR,ARP,IB,NUM,LOWL,NUMB,PREV)
      INTEGER STP,DUMMY,PREV(N),ARP(N)
      DIMENSION IP(N),ICN(LICN),LENR(N),IB(N),LOWL(N),NUMB(N)
C
C ARP(I) IS ONE LESS THAN THE NUMBER OF UNSEARCHED EDGES LEAVING
C     NODE I.  AT THE END OF THE ALGORITHM IT IS SET TO A
C     PERMUTATION WHICH PUTS THE MATRIX IN BLOCK LOWER
C     TRIANGULAR FORM.
C IB(I) IS THE POSITION IN THE ORDERING OF THE START OF THE ITH
C     BLOCK.  IB(N+1-I) HOLDS THE NODE NUMBER OF THE ITH NODE
C     ON THE STACK.
C LOWL(I) IS THE SMALLEST STACK POSITION OF ANY NODE TO WHICH A PATH
C     FROM NODE I HAS BEEN FOUND.  IT IS SET TO N+1 WHEN NODE I
C     IS REMOVED FROM THE STACK.
C NUMB(I) IS THE POSITION OF NODE I IN THE STACK IF IT IS ON
C     IT, IS THE PERMUTED ORDER OF NODE I FOR THOSE NODES
C     WHOSE FINAL POSITION HAS BEEN FOUND AND IS OTHERWISE ZERO.
C PREV(I) IS THE NODE AT THE END OF THE PATH WHEN NODE I WAS
C     PLACED ON THE STACK.
C   ICNT IS THE NUMBER OF NODES WHOSE POSITIONS IN FINAL ORDERING HAVE
C     BEEN FOUND.
C
      ICNT=0
C NUM IS THE NUMBER OF BLOCKS THAT HAVE BEEN FOUND.
      NUM=0
      NNM1=N+N-1
C
C INITIALIZATION OF ARRAYS.
      DO 20 J=1,N
      NUMB(J)=0
      ARP(J)=LENR(J)-1
   20 CONTINUE
C
      DO 120 ISN=1,N
C LOOK FOR A STARTING NODE
      IF (NUMB(ISN).NE.0) GO TO 120
      IV=ISN
C IST IS THE NUMBER OF NODES ON THE STACK ... IT IS THE STACK POINTER.
      IST=1
C PUT NODE IV AT BEGINNING OF STACK.
      LOWL(IV)=1
      NUMB(IV)=1
      IB(N)=IV
C
C THE BODY OF THIS LOOP PUTS A NEW NODE ON THE STACK OR BACKTRACKS.
      DO 110 DUMMY=1,NNM1
      I1=ARP(IV)
C HAVE ALL EDGES LEAVING NODE IV BEEN SEARCHED.
      IF (I1.LT.0) GO TO 60
      I2=IP(IV)+LENR(IV)-1
      I1=I2-I1
C
C LOOK AT EDGES LEAVING NODE IV UNTIL ONE ENTERS A NEW NODE OR
C     ALL EDGES ARE EXHAUSTED.
      DO 50 II=I1,I2
      IW=ICN(II)
C HAS NODE IW BEEN ON STACK ALREADY.
      IF (NUMB(IW).EQ.0) GO TO 100
C UPDATE VALUE OF LOWL(IV) IF NECESSARY.
C
C THERE ARE NO MORE EDGES LEAVING NODE IV.
   50 LOWL(IV)=MIN0(LOWL(IV),LOWL(IW))
      ARP(IV)=-1
C IS NODE IV THE ROOT OF A BLOCK.
   60 IF (LOWL(IV).LT.NUMB(IV)) GO TO 90
C
C ORDER NODES IN A BLOCK.
      NUM=NUM+1
      IST1=N+1-IST
      LCNT=ICNT+1
C PEEL BLOCK OFF THE TOP OF THE STACK STARTING AT THE TOP AND
C     WORKING DOWN TO THE ROOT OF THE BLOCK.
      DO 70 STP=IST1,N
      IW=IB(STP)
      LOWL(IW)=N+1
      ICNT=ICNT+1
      NUMB(IW)=ICNT
      IF (IW.EQ.IV) GO TO 80
   70 CONTINUE
   80 IST=N-STP
      IB(NUM)=LCNT
C ARE THERE ANY NODES LEFT ON THE STACK.
      IF (IST.NE.0) GO TO 90
C HAVE ALL THE NODES BEEN ORDERED.
      IF (ICNT.LT.N) GO TO 120
      GO TO 130
C
C BACKTRACK TO PREVIOUS NODE ON PATH.
   90 IW=IV
      IV=PREV(IV)
C UPDATE VALUE OF LOWL(IV) IF NECESSARY.
      LOWL(IV)=MIN0(LOWL(IV),LOWL(IW))
      GO TO 110
C
C PUT NEW NODE ON THE STACK.
  100 ARP(IV)=I2-II-1
      PREV(IW)=IV
      IV=IW
      IST=IST+1
      LOWL(IV)=IST
      NUMB(IV)=IST
      K=N+1-IST
      IB(K)=IV
  110 CONTINUE
C
  120 CONTINUE
C
C
C PUT PERMUTATION IN THE REQUIRED FORM.
  130 DO 140 I=1,N
      II=NUMB(I)
  140 ARP(II)=I
      RETURN
      END
C
C
C
      SUBROUTINE MC22A(N,ICN,A,NZ,LENROW,IP,IQ,IW,IW1)
      DIMENSION A(NZ),IW(N,2),ICN(NZ),LENROW(N),IP(N),IQ(N),IW1(NZ)
      IF (NZ.LE.0) GO TO 1000
      IF (N.LE.0) GO TO 1000
C SET START OF ROW I IN IW(I,1) AND LENROW(I) IN IW(I,2)
      IW(1,1)=1
      IW(1,2)=LENROW(1)
      DO 10 I=2,N
      IW(I,1)=IW(I-1,1)+LENROW(I-1)
   10 IW(I,2)=LENROW(I)
C PERMUTE LENROW ACCORDING TO IP.  SET OFF-SETS FOR NEW POSITION
C     OF ROW IOLD IN IW(IOLD,1) AND PUT OLD ROW INDICES IN IW1 IN
C     POSITIONS CORRESPONDING TO THE NEW POSITION OF THIS ROW IN A/ICN.
      JJ=1
      DO 20 I=1,N
      IOLD=IP(I)
      IOLD=IABS(IOLD)
      LENGTH=IW(IOLD,2)
      LENROW(I)=LENGTH
      IF (LENGTH.EQ.0) GO TO 20
      IW(IOLD,1)=IW(IOLD,1)-JJ
      J2=JJ+LENGTH-1
      DO 15 J=JJ,J2
   15 IW1(J)=IOLD
      JJ=J2+1
   20 CONTINUE
C SET INVERSE PERMUTATION TO IQ IN IW(.,2).
      DO 30 I=1,N
      IOLD=IQ(I)
      IOLD=IABS(IOLD)
   30 IW(IOLD,2)=I
C PERMUTE A AND ICN IN PLACE, CHANGING TO NEW COLUMN NUMBERS.
C
C ***   MAIN LOOP   ***
C EACH PASS THROUGH THIS LOOP PLACES A CLOSED CHAIN OF COLUMN INDICES
C     IN THEIR NEW (AND FINAL) POSITIONS ... THIS IS RECORDED BY
C     SETTING THE IW1 ENTRY TO ZERO SO THAT ANY WHICH ARE SUBSEQUENTLY
C     ENCOUNTERED DURING THIS MAJOR SCAN CAN BE BYPASSED.
      DO 200 I=1,NZ
      IOLD=IW1(I)
      IF (IOLD.EQ.0) GO TO 200
      IPOS=I
      JVAL=ICN(I)
C IF ROW IOLD IS IN SAME POSITIONS AFTER PERMUTATION GO TO 150.
      IF (IW(IOLD,1).EQ.0) GO TO 150
      AVAL=A(I)
C **  CHAIN LOOP  **
C EACH PASS THROUGH THIS LOOP PLACES ONE (PERMUTED) COLUMN INDEX
C     IN ITS FINAL POSITION  .. VIZ. IPOS.
      DO 100 ICHAIN=1,NZ
C NEWPOS IS THE ORIGINAL POSITION IN A/ICN OF THE ELEMENT TO BE PLACED
C IN POSITION IPOS.  IT IS ALSO THE POSITION OF THE NEXT ELEMENT IN
C     THE CHAIN.
      NEWPOS=IPOS+IW(IOLD,1)
C IS CHAIN COMPLETE ?
      IF (NEWPOS.EQ.I) GO TO 130
      A(IPOS)=A(NEWPOS)
      JNUM=ICN(NEWPOS)
      ICN(IPOS)=IW(JNUM,2)
      IPOS=NEWPOS
      IOLD=IW1(IPOS)
      IW1(IPOS)=0
C **  END OF CHAIN LOOP  **
  100 CONTINUE
  130 A(IPOS)=AVAL
  150 ICN(IPOS)=IW(JVAL,2)
C ***   END OF MAIN LOOP   ***
  200 CONTINUE
C
 1000 RETURN
      END
C
C
C
      SUBROUTINE MC23A (N,ICN,A,LICN,LENR,IDISP,IP,IQ,LENOFF,IW,IW1)
      DIMENSION A(LICN),IDISP(2),IW1(N,2),ICN(LICN),LENR(N),IP(N),
     $          IQ(N),LENOFF(N),IW(N,5)
      LOGICAL ABORT
C INPUT ... N,ICN .. A,ICN,LENR ....
C
C SET UP POINTERS IW(.,1) TO THE BEGINNING OF THE ROWS AND SET LENOFF
C     EQUAL TO LENR.
      COMMON /MC23B/ LP,NUMNZ,NUM,LARGE,ABORT
      IW1(1,1)=1
      LENOFF(1)=LENR(1)
      IF (N.EQ.1) GO TO 20
      DO 10 I=2,N
      LENOFF(I)=LENR(I)
   10 IW1(I,1)=IW1(I-1,1)+LENR(I-1)
C IDISP(1) POINTS TO THE FIRST POSITION IN A/ICN AFTER THE
C     OFF-DIAGONAL BLOCKS AND UNTREATED ROWS.
   20 IDISP(1)=IW1(N,1)+LENR(N)
C
C FIND ROW PERMUTATION IP TO MAKE DIAGONAL ZERO-FREE.
      CALL MC21A(N,ICN,LICN,IW1,LENR,IP,NUMNZ,IW)
C
C POSSIBLE ERROR RETURN FOR STRUCTURALLY SINGULAR MATRICES.
      IF (NUMNZ.NE.N.AND.ABORT) GO TO 170
C
C IW1(.,2) AND LENR ARE PERMUTATIONS OF IW1(.,1) AND LENR/LENOFF
C     SUITABLE FOR ENTRY
C     TO MC13D SINCE MATRIX WITH THESE ROW POINTER AND LENGTH ARRAYS
C     HAS MAXIMUM NUMBER OF NON-ZEROS ON THE DIAGONAL.
      DO 30 II=1,N
      I=IP(II)
      IW1(II,2)=IW1(I,1)
   30 LENR(II)=LENOFF(I)
C
C FIND SYMMETRIC PERMUTATION IQ TO BLOCK LOWER TRIANGULAR FORM.
      CALL MC13D(N,ICN,LICN,IW1(1,2),LENR,IQ,IW(1,4),NUM,IW)
C
      IF (NUM.NE.1) GO TO 60
C
C ACTION TAKEN IF MATRIX IS IRREDUCIBLE.
C WHOLE MATRIX IS JUST MOVED TO THE END OF THE STORAGE.
      DO 40 I=1,N
      LENR(I)=LENOFF(I)
      IP(I)=I
   40 IQ(I)=I
      LENOFF(1)=-1
C IDISP(1) IS THE FIRST POSITION AFTER THE LAST ELEMENT IN THE
C     OFF-DIAGONAL BLOCKS AND UNTREATED ROWS.
      NZ=IDISP(1)-1
      IDISP(1)=1
C IDISP(2) IS THE POSITION IN A/ICN OF THE FIRST ELEMENT IN THE
C     DIAGONAL BLOCKS.
      IDISP(2)=LICN-NZ+1
      LARGE=N
      IF (NZ.EQ.LICN) GO TO 230
      DO 50 K=1,NZ
      J=NZ-K+1
      JJ=LICN-K+1
      A(JJ)=A(J)
   50 ICN(JJ)=ICN(J)
C 230 = RETURN
      GO TO 230
C
C DATA STRUCTURE REORDERED.
C
C FORM COMPOSITE ROW PERMUTATION ... IP(I) = IP(IQ(I)).
   60 DO 70 II=1,N
      I=IQ(II)
   70 IW(II,1)=IP(I)
      DO 80 I=1,N
   80 IP(I)=IW(I,1)
C
C RUN THROUGH BLOCKS IN REVERSE ORDER SEPARATING DIAGONAL BLOCKS
C     WHICH ARE MOVED TO THE END OF THE STORAGE.  ELEMENTS IN
C     OFF-DIAGONAL BLOCKS ARE LEFT IN PLACE UNLESS A COMPRESS IS
C     NECESSARY.
C
C IBEG INDICATES THE LOWEST VALUE OF J FOR WHICH ICN(J) HAS BEEN
C     SET TO ZERO WHEN ELEMENT IN POSITION J WAS MOVED TO THE
C     DIAGONAL BLOCK PART OF STORAGE.
      IBEG=LICN+1
C IEND IS THE POSITION OF THE FIRST ELEMENT OF THOSE TREATED ROWS
C     WHICH ARE IN DIAGONAL BLOCKS.
      IEND=LICN+1
C LARGE IS THE DIMENSION OF THE LARGEST BLOCK ENCOUNTERED SO FAR.
      LARGE=0
C
C NUM IS THE NUMBER OF DIAGONAL BLOCKS.
      DO 150 K=1,NUM
      IBLOCK=NUM-K+1
C I1 IS FIRST ROW (IN PERMUTED FORM) OF BLOCK IBLOCK.
C I2 IS LAST ROW (IN PERMUTED FORM) OF BLOCK IBLOCK.
      I1=IW(IBLOCK,4)
      I2=N
      IF (K.NE.1) I2=IW(IBLOCK+1,4)-1
      LARGE=MAX0(LARGE,I2-I1+1)
C GO THROUGH THE ROWS OF BLOCK IBLOCK IN THE REVERSE ORDER.
      DO 140 II=I1,I2
      INEW=I2-II+I1
C WE NOW DEAL WITH ROW INEW IN PERMUTED FORM (ROW IOLD IN ORIGINAL
C     MATRIX).
      IOLD=IP(INEW)
C IF THERE IS SPACE TO MOVE UP DIAGONAL BLOCK PORTION OF ROW GO TO 110
      IF (IEND-IDISP(1).GE.LENOFF(IOLD)) GO TO 110
C
C IN-LINE COMPRESS.
C MOVES SEPARATED OFF-DIAGONAL ELEMENTS AND UNTREATED ROWS TO
C     FRONT OF STORAGE.
      JNPOS=IBEG
      ILEND=IDISP(1)-1
      IF (ILEND.LT.IBEG) GO TO 190
      DO 90 J=IBEG,ILEND
      IF (ICN(J).EQ.0) GO TO 90
      ICN(JNPOS)=ICN(J)
      A(JNPOS)=A(J)
      JNPOS=JNPOS+1
   90 CONTINUE
      IDISP(1)=JNPOS
      IF (IEND-JNPOS.LT.LENOFF(IOLD)) GO TO 190
      IBEG=LICN+1
C RESET POINTERS TO THE BEGINNING OF THE ROWS.
      DO 100 I=2,N
  100 IW1(I,1)=IW1(I-1,1)+LENOFF(I-1)
C
C ROW IOLD IS NOW SPLIT INTO DIAG. AND OFF-DIAG. PARTS.
  110 IROWB=IW1(IOLD,1)
      LENI=0
      IROWE=IROWB+LENOFF(IOLD)-1
C BACKWARD SCAN OF WHOLE OF ROW IOLD (IN ORIGINAL MATRIX).
      IF (IROWE.LT.IROWB) GO TO 130
      DO 120 JJ=IROWB,IROWE
      J=IROWE-JJ+IROWB
      JOLD=ICN(J)
C IW(.,2) HOLDS THE INVERSE PERMUTATION TO IQ.
C     ..... IT WAS SET TO THIS IN MC13D.
      JNEW=IW(JOLD,2)
C IF (JNEW.LT.I1) THEN ....
C ELEMENT IS IN OFF-DIAGONAL BLOCK AND SO IS LEFT IN SITU.
      IF (JNEW.LT.I1) GO TO 120
C ELEMENT IS IN DIAGONAL BLOCK AND IS MOVED TO THE END OF THE STORAGE.
      IEND=IEND-1
      A(IEND)=A(J)
      ICN(IEND)=JNEW
      IBEG=MIN0(IBEG,J)
      ICN(J)=0
      LENI=LENI+1
  120 CONTINUE
C
      LENOFF(IOLD)=LENOFF(IOLD)-LENI
  130 LENR(INEW)=LENI
  140 CONTINUE
C
      IP(I2)=-IP(I2)
  150 CONTINUE
C RESETS IP(N) TO POSITIVE VALUE.
      IP(N)=-IP(N)
C IDISP(2) IS POSITION OF FIRST ELEMENT IN DIAGONAL BLOCKS.
      IDISP(2)=IEND
C
C THIS COMPRESS IS USED TO MOVE ALL OFF-DIAGONAL ELEMENTS TO THE
C     FRONT OF THE STORAGE.
      IF (IBEG.GT.LICN) GO TO 230
      JNPOS=IBEG
      ILEND=IDISP(1)-1
      DO 160 J=IBEG,ILEND
      IF (ICN(J).EQ.0) GO TO 160
      ICN(JNPOS)=ICN(J)
      A(JNPOS)=A(J)
      JNPOS=JNPOS+1
  160 CONTINUE
C IDISP(1) IS FIRST POSITION AFTER LAST ELEMENT OF OFF-DIAGONAL BLOCKS.
      IDISP(1)=JNPOS
      GO TO 230
C
C ERROR RETURN
  170 IF (LP.NE.0) WRITE(LP,180) NUMNZ
  180 FORMAT(33X,' MATRIX IS STRUCTURALLY SINGULAR, RANK = ',I6)
      IDISP(1)=-1
      GO TO 210
  190 IF (LP.NE.0) WRITE(LP,200) N
  200 FORMAT(33X,' LICN NOT BIG ENOUGH INCREASE BY ',I6)
      IDISP(1)=-2
  210 IF (LP.NE.0) WRITE(LP,220)
  220 FORMAT('+ERROR RETURN FROM MC23A  BECAUSE')
  230 RETURN
      END
C
C
C
      SUBROUTINE MC24A(N,ICN,A,LICN,LENR,LENRL,W)
      DIMENSION A(LICN),W(N),ICN(LICN),LENR(N),LENRL(N)
      DATA ZERO /0.0/
      AMAXL=ZERO
      DO 10 I=1,N
   10 W(I)=ZERO
      J0=1
      DO 100 I=1,N
      IF (LENR(I).EQ.0) GO TO 100
      J2=J0+LENR(I)-1
      IF (LENRL(I).EQ.0) GO TO 50
C CALCULATION OF 1-NORM OF L.
      J1=J0+LENRL(I)-1
      WROWL=ZERO
      DO 30 JJ=J0,J1
C AMAXL IS THE MAXIMUM NORM OF COLUMNS OF L SO FAR FOUND.
   30 WROWL=WROWL+ABS(A(JJ))
      AMAXL=AMAX1(AMAXL,WROWL)
      J0=J1+1
C CALCULATION OF NORMS OF COLUMNS OF U (MAX-NORMS).
   50 J0=J0+1
      IF (J0.GT.J2) GO TO 90
      DO 80 JJ=J0,J2
      J=ICN(JJ)
   80 W(J)=AMAX1(ABS(A(JJ)),W(J))
   90 J0=J2+1
  100 CONTINUE
C AMAXU IS SET TO MAXIMUM MAX-NORM OF COLUMNS OF U.
      AMAXU=ZERO
      DO 200 I=1,N
C GROFAC IS MAX U MAX-NORM TIMES MAX L 1-NORM.
  200 AMAXU=AMAX1(AMAXU,W(I))
      W(1)=AMAXL*AMAXU
      RETURN
      END
C
C
C
      SUBROUTINE MA30A(NN,ICN,A,LICN,LENR,LENRL,IDISP,IP,IQ,IRN,
     $   LIRN,LENC,IFIRST,LASTR,NEXTR,LASTC,NEXTC,IPTR,IPC,U,IFLAG)
      DIMENSION A(LICN),IPTR(NN),IPC(NN),IDISP(2),ICN(LICN),LENR(NN),
     $          LENRL(NN),IP(NN),IQ(NN),LENC(NN),IRN(LIRN),
     $          IFIRST(NN),LASTR(NN),NEXTR(NN),LASTC(NN),NEXTC(NN)
      INTEGER PIVOT,PIVEND,DISPC,OLDPIV,OLDEND,PIVROW,ROWI
      LOGICAL ABORT1,ABORT2,ABORT3
      COMMON /MA30E/ LP,ABORT1,ABORT2,ABORT3
            DATA UMAX/.9999/
C
      DATA ZERO/0.0/
      MINIRN=0
      MINICN=IDISP(1)-1
      MOREI=0
      IRANK=NN
      IRNCP=0
      ICNCP=0
      IFLAG=0
C RESET U IF NECESSARY.
      U=AMIN1(U,UMAX)
C IBEG IS THE POSITION OF THE NEXT PIVOT ROW AFTER ELIMINATION STEP
C     USING IT.
      U=AMAX1(U,ZERO)
      IBEG=IDISP(1)
C IACTIV IS THE POSITION OF THE FIRST ENTRY IN THE ACTIVE PART OF A/ICN.
      IACTIV=IDISP(2)
C NZROW IS CURRENT NUMBER OF NON-ZEROS IN ACTIVE AND UNPROCESSED PART
C     OF ROW FILE ICN.
      NZROW=LICN-IACTIV+1
      MINICN=NZROW+MINICN
C
C COUNT THE NUMBER OF DIAGONAL BLOCKS AND SET UP POINTERS TO THE
C     BEGINNINGS OF THE ROWS.
C NUM IS THE NUMBER OF DIAGONAL BLOCKS.
      NUM=1
      IPTR(1)=IACTIV
      IF (NN.EQ.1) GO TO 20
      NNM1=NN-1
      DO 10 I=1,NNM1
      IF (IP(I).LT.0) NUM=NUM+1
   10 IPTR(I+1)=IPTR(I)+LENR(I)
C ILAST IS THE LAST ROW IN THE PREVIOUS BLOCK.
   20 ILAST=0
C
C ***********************************************
C ****    LU DECOMPOSITION OF BLOCK NBLOCK   ****
C ***********************************************
C
C EACH PASS THROUGH THIS LOOP PERFORMS LU DECOMPOSITION ON ONE
C     OF THE DIAGONAL BLOCKS.
      DO 950 NBLOCK=1,NUM
      ISTART=ILAST+1
      DO 30 IROWS=ISTART,NN
      IF (IP(IROWS).LT.0) GO TO 40
   30 CONTINUE
      IROWS=NN
   40 ILAST=IROWS
C N IS THE NUMBER OF ROWS IN THE CURRENT BLOCK.
C ISTART IS THE INDEX OF THE FIRST ROW IN THE CURRENT BLOCK.
C ILAST IS THE INDEX OF THE LAST ROW IN THE CURRENT BLOCK.
C IACTIV IS THE POSITION OF THE FIRST ELEMENT IN THE BLOCK.
C ITOP IS THE POSITION OF THE LAST ELEMENT IN THE BLOCK.
      N=ILAST-ISTART+1
      IF (N.NE.1) GO TO 100
C
C CODE FOR DEALING WITH 1X1 BLOCK.
      LENRL(ILAST)=0
      ISING=ISTART
      IF (LENR(ILAST).NE.0) GO TO 60
C BLOCK IS STRUCTURALLY SINGULAR.
      IRANK=IRANK-1
      ISING=-ISING
      IF (IFLAG.NE.2.AND.IFLAG.NE.-5) IFLAG=1
      IF (.NOT.ABORT1) GO TO 90
      IDISP(2)=IACTIV
      IFLAG=-1
      IF (LP.NE.0) WRITE(LP,50)
   50 FORMAT(' ERROR RETURN FROM MA30A BECAUSE MATRIX IS ',
     $   'STRUCTURALLY SINGULAR')
C     RETURN
      GO TO 1110
   60 IF (A(IACTIV).NE.ZERO) GO TO 80
      ISING=-ISING
      IRANK=IRANK-1
      IPTR(ILAST)=0
      IF (IFLAG.NE.-5) IFLAG=2
      IF (.NOT.ABORT2) GO TO 80
      IDISP(2)=IACTIV
      IFLAG=-2
      IF (LP.NE.0) WRITE(LP,70)
   70 FORMAT (' ERROR RETURN FROM MA30A BECAUSE MATRIX IS ',
     $   'NUMERICALLY SINGULAR')
      GO TO 1110
   80 A(IBEG)=A(IACTIV)
      ICN(IBEG)=ICN(IACTIV)
      IACTIV=IACTIV+1
      IPTR(ISTART)=0
      IBEG=IBEG+1
      NZROW=NZROW-1
   90 LASTR(ISTART)=ISTART
      LASTC(ISTART)=ISING
      GO TO 950
C
C NON-TRIVIAL BLOCK.
  100 ITOP=LICN
      IF (ILAST.NE.NN) ITOP=IPTR(ILAST+1)-1
C
C SET UP COLUMN ORIENTED STORAGE.
      DO 110 I=ISTART,ILAST
      LENRL(I)=0
  110 LENC(I)=0
      IF (ITOP-IACTIV.LT.LIRN) GO TO 120
      MINIRN=ITOP-IACTIV+1
      PIVOT=ISTART-1
      GO TO 1050
C
C CALCULATE COLUMN COUNTS.
  120 DO 130 II=IACTIV,ITOP
      I=ICN(II)
  130 LENC(I)=LENC(I)+1
C SET UP COLUMN POINTERS SO THAT IPC(J) POINTS TO POSITION AFTER END
C     OF COLUMN J IN COLUMN FILE.
      IPC(ILAST)=LIRN+1
      J1=ISTART+1
      DO 140 JJ=J1,ILAST
      J=ILAST-JJ+J1-1
  140 IPC(J)=IPC(J+1)-LENC(J+1)
      DO 160 INDROW=ISTART,ILAST
      J1=IPTR(INDROW)
      J2=J1+LENR(INDROW)-1
      IF (J1.GT.J2) GO TO 160
      DO 150 JJ=J1,J2
      J=ICN(JJ)
      IPOS=IPC(J)-1
      IRN(IPOS)=INDROW
      IPC(J)=IPOS
  150 CONTINUE
  160 CONTINUE
C DISPC IS THE LOWEST INDEXED ACTIVE LOCATION IN THE COLUMN FILE.
      DISPC=IPC(ISTART)
      NZCOL=LIRN-DISPC+1
      MINIRN=MAX0(NZCOL,MINIRN)
      NZMIN=1
C
C INITIALIZE ARRAY IFIRST.  IFIRST(I) = +/- K INDICATES THAT ROW/COL
C     K HAS I NON-ZEROS.  IF IFIRST(I) = 0, THERE IS NO ROW OR COLUMN
C     WITH I NON ZEROS.
      DO 170 I=1,N
  170 IFIRST(I)=0
C
C COMPUTE ORDERING OF ROW AND COLUMN COUNTS.
C FIRST RUN THROUGH COLUMNS (FROM COLUMN N TO COLUMN 1).
      DO 190 JJ=ISTART,ILAST
      J=ILAST-JJ+ISTART
      NZ=LENC(J)
      IF (NZ.NE.0) GO TO 180
      IPC(J)=0
      LASTC(J)=0
      GO TO 190
  180 ISW=IFIRST(NZ)
      IFIRST(NZ)=-J
      LASTC(J)=0
      NEXTC(J)=-ISW
      ISW1=IABS(ISW)
      IF (ISW.NE.0) LASTC(ISW1)=J
  190 CONTINUE
C NOW RUN THROUGH ROWS (AGAIN FROM N TO 1).
      DO 210 II=ISTART,ILAST
      I=ILAST-II+ISTART
      NZ=LENR(I)
      IF (NZ.NE.0) GO TO 200
      IPTR(I)=0
      LASTR(I)=0
      GO TO 210
  200 ISW=IFIRST(NZ)
      IFIRST(NZ)=I
      IF (ISW.GT.0) GO TO 205
      NEXTR(I)=0
      LASTR(I)=ISW
      GO TO 210
  205 NEXTR(I)=ISW
      LASTR(I)=LASTR(ISW)
      LASTR(ISW)=I
  210 CONTINUE
C
C **********************************************
C ****    START OF MAIN ELIMINATION LOOP    ****
C **********************************************
      DO 930 PIVOT=ISTART,ILAST
C
C FIRST FIND THE PIVOT USING MARKOWITZ CRITERION WITH STABILITY
C     CONTROL.
C JCOST IS THE MARKOWITZ COST OF THE BEST PIVOT SO FAR,.. THIS
C     PIVOT IS IN ROW IPIV AND COLUMN JPIV.
      NZ2=NZMIN
      JCOST=N*N
C
C EXAMINE ROWS/COLUMNS IN ORDER OF ASCENDING COUNT.
      DO 290 L=1,2
      LL=L
C A PASS WITH L EQUAL TO 2 IS ONLY PERFORMED IN THE CASE OF SINGULARITY.
      DO 280 NZ=NZ2,N
      IF (JCOST.LE.(NZ-1)**2) GO TO 380
      IJFIR=IFIRST(NZ)
      IF (IJFIR) 212,211,215
  211 IF (LL.EQ.1) NZMIN=NZ+1
      GO TO 280
  212 LL=2
      IJFIR=-IJFIR
      GO TO 245
  215 LL=2
C SCAN ROWS WITH NZ NON-ZEROS.
      DO 235 IDUMMY=1,N
      IF (IJFIR.EQ.0) GO TO 240
C ROW IJFIR IS NOW EXAMINED.
      I=IJFIR
      IJFIR=NEXTR(I)
C FIRST CALCULATE MULTIPLIER THRESHOLD LEVEL.
      AMAX=ZERO
      J1=IPTR(I)+LENRL(I)
      J2=IPTR(I)+LENR(I)-1
      DO 220 JJ=J1,J2
  220 AMAX=AMAX1(AMAX,ABS(A(JJ)))
      AU=AMAX*U
C SCAN ROW FOR POSSIBLE PIVOTS
      DO 230 JJ=J1,J2
      IF (ABS(A(JJ)).LE.AU.AND.L.EQ.1) GO TO 230
      J=ICN(JJ)
      KCOST=(NZ-1)*(LENC(J)-1)
      IF (KCOST.GE.JCOST) GO TO 230
C BEST PIVOT SO FAR IS FOUND.
      JCOST=KCOST
      IJPOS=JJ
      IPIV=I
      JPIV=J
      IF (JCOST.LE.(NZ-1)**2) GO TO 380
  230 CONTINUE
  235 CONTINUE
C
C COLUMNS WITH NZ NON-ZEROS NOW EXAMINED.
  240 IJFIR=IFIRST(NZ)
      IJFIR=-LASTR(IJFIR)
  245 IF (JCOST.LE.NZ*(NZ-1)) GO TO 380
      DO 270 IDUMMY=1,N
      IF (IJFIR.EQ.0) GO TO 280
      J=IJFIR
      IJFIR=NEXTC(IJFIR)
      I1=IPC(J)
      I2=I1+NZ-1
C SCAN COLUMN J.
      DO 260 II=I1,I2
      I=IRN(II)
      KCOST=(NZ-1)*(LENR(I)-LENRL(I)-1)
      IF (KCOST.GE.JCOST) GO TO 260
C PIVOT HAS BEST MARKOWITZ COUNT SO FAR ... NOW CHECK ITS
C     SUITABILITY ON NUMERIC GROUNDS BY EXAMINING THE OTHER NON-ZEROS
C     IN ITS ROW.
      J1=IPTR(I)+LENRL(I)
      J2=IPTR(I)+LENR(I)-1
C WE NEED A STABILITY CHECK ON SINGLETON COLUMNS BECAUSE OF POSSIBLE
C     PROBLEMS WITH UNDERDETERMINED SYSTEMS.
      AMAX=ZERO
      DO 250 JJ=J1,J2
      AMAX=AMAX1(AMAX,ABS(A(JJ)))
  250 IF (ICN(JJ).EQ.J) JPOS=JJ
      IF (ABS(A(JPOS)).LE.AMAX*U.AND.L.EQ.1) GO TO 260
      JCOST=KCOST
      IPIV=I
      JPIV=J
      IJPOS=JPOS
      IF (JCOST.LE.NZ*(NZ-1)) GO TO 380
  260 CONTINUE
C
  270 CONTINUE
C
  280 CONTINUE
C
C MATRIX IS NUMERICALLY OR STRUCTURALLY SINGULAR  ... WHICH IT IS WILL
C     BE DIAGNOSED LATER.
      IRANK=IRANK-1
  290 CONTINUE
C ASSIGN REST OF ROWS AND COLUMNS TO ORDERING ARRAY.
C MATRIX IS STRUCTURALLY SINGULAR.
      IF (IFLAG.NE.2.AND.IFLAG.NE.-5) IFLAG=1
      IRANK=IRANK-ILAST+PIVOT+1
      IF (.NOT.ABORT1) GO TO 300
      IDISP(2)=IACTIV
      IFLAG=-1
      IF (LP.NE.0) WRITE(LP,50)
      GO TO 1110
  300 K=PIVOT-1
      DO 350 I=ISTART,ILAST
      IF (LASTR(I).NE.0) GO TO 350
      K=K+1
      LASTR(I)=K
      IF (LENRL(I).EQ.0) GO TO 340
      MINICN=MAX0(MINICN,NZROW+IBEG-1+MOREI+LENRL(I))
      IF (IACTIV-IBEG.GE.LENRL(I)) GO TO 320
C CHECK NOW TO SEE IF MA30D HAS CREATED ENOUGH AVAILABLE SPACE.
      CALL MA30D(A,ICN,IPTR(ISTART),N,IACTIV,ITOP,.TRUE.)
      IF (IACTIV-IBEG.GE.LENRL(I)) GO TO 320
C CREATE MORE SPACE BY DESTROYING PREVIOUSLY CREATED LU FACTORS.
      MOREI=MOREI+IBEG-IDISP(1)
      IBEG=IDISP(1)
      IF (LP.NE.0) WRITE(LP,310)
      IFLAG=-5
  310 FORMAT(' LU DECOMPOSITION DESTROYED TO CREATE MORE SPACE')
      IF (ABORT3) GO TO 1030
  320 J1=IPTR(I)
      J2=J1+LENRL(I)-1
      IPTR(I)=0
      DO 330 JJ=J1,J2
      A(IBEG)=A(JJ)
      ICN(IBEG)=ICN(JJ)
      ICN(JJ)=0
  330 IBEG=IBEG+1
      NZROW=NZROW-LENRL(I)
  340 IF (K.EQ.ILAST) GO TO 360
  350 CONTINUE
  360 K=PIVOT-1
      DO 370 I=ISTART,ILAST
      IF (LASTC(I).NE.0) GO TO 370
      K=K+1
      LASTC(I)=-K
      IF (K.EQ.ILAST) GO TO 940
  370 CONTINUE
C
C THE PIVOT HAS NOW BEEN FOUND IN POSITION (IPIV,JPIV) IN LOCATION
C     IJPOS IN ROW FILE.
C UPDATE COLUMN AND ROW ORDERING ARRAYS TO CORRESPOND WITH REMOVAL
C     OF THE ACTIVE PART OF THE MATRIX.
  380 ISING=PIVOT
      IF (A(IJPOS).NE.ZERO) GO TO 390
C NUMERICAL SINGULARITY IS RECORDED HERE.
      ISING=-ISING
      IF (IFLAG.NE.-5) IFLAG=2
      IF (.NOT.ABORT2) GO TO 390
      IDISP(2)=IACTIV
      IFLAG=-2
      IF (LP.NE.0) WRITE(LP,70)
      GO TO 1110
  390 OLDPIV=IPTR(IPIV)+LENRL(IPIV)
      OLDEND=IPTR(IPIV)+LENR(IPIV)-1
C CHANGES TO COLUMN ORDERING.
      DO 460 JJ=OLDPIV,OLDEND
      J=ICN(JJ)
      LC=LASTC(J)
      NC=NEXTC(J)
      IF (NC.NE.0) LASTC(NC)=LC
      IF (LC.EQ.0) GO TO 440
      NEXTC(LC)=NC
      GO TO 460
  440 NZ=LENC(J)
      ISW=IFIRST(NZ)
      IF (ISW.GT.0) LASTR(ISW)=-NC
      IF (ISW.LT.0) IFIRST(NZ)=-NC
  460 CONTINUE
C CHANGES TO ROW ORDERING.
      I1=IPC(JPIV)
      I2=I1+LENC(JPIV)-1
      DO 530 II=I1,I2
      I=IRN(II)
      LR=LASTR(I)
      NR=NEXTR(I)
      IF (NR.NE.0) LASTR(NR)=LR
      IF (LR.LE.0) GO TO 500
      NEXTR(LR)=NR
      GO TO 530
  500 NZ=LENR(I)-LENRL(I)
      IF (NR.NE.0) IFIRST(NZ)=NR
      IF (NR.EQ.0) IFIRST(NZ)=LR
  530 CONTINUE
C     RECORD THE COLUMN PERMUTATION IN LASTC(JPIV) AND THE ROW
C     PERMUTATION IN LASTR(IPIV).
      LASTC(JPIV)=ISING
      LASTR(IPIV)=PIVOT
C
C MOVE PIVOT TO POSITION LENRL+1 IN PIVOT ROW AND MOVE PIVOT ROW
C     TO THE BEGINNING OF THE AVAILABLE STORAGE.
C THE L PART AND THE PIVOT IN THE OLD COPY OF THE PIVOT ROW IS
C     NULLIFIED WHILE, IN THE STRICTLY UPPER TRIANGULAR PART, THE
C     COLUMN INDICES, J SAY, ARE OVERWRITTEN BY THE CORRESPONDING
C     ELEMENT OF IQ (IQ(J)) AND IQ(J) IS SET TO THE NEGATIVE OF THE
C     DISPLACEMENT OF THE COLUMN INDEX FROM THE PIVOT ELEMENT.
      IF (OLDPIV.EQ.IJPOS) GO TO 540
      AU=A(OLDPIV)
      A(OLDPIV)=A(IJPOS)
      A(IJPOS)=AU
      ICN(IJPOS)=ICN(OLDPIV)
      ICN(OLDPIV)=JPIV
C CHECK TO SEE IF THERE IS SPACE IMMEDIATELY AVAILABLE IN A/ICN TO
C     HOLD NEW COPY OF PIVOT ROW.
  540 MINICN=MAX0(MINICN,NZROW+IBEG-1+MOREI+LENR(IPIV))
      IF (IACTIV-IBEG.GE.LENR(IPIV)) GO TO 550
      CALL MA30D(A,ICN,IPTR(ISTART),N,IACTIV,ITOP,.TRUE.)
      OLDPIV=IPTR(IPIV)+LENRL(IPIV)
      OLDEND=IPTR(IPIV)+LENR(IPIV)-1
C CHECK NOW TO SEE IF MA30D HAS CREATED ENOUGH AVAILABLE SPACE.
      IF (IACTIV-IBEG.GE.LENR(IPIV)) GO TO 550
C CREATE MORE SPACE BY DESTROYING PREVIOUSLY CREATED LU FACTORS.
      MOREI=MOREI+IBEG-IDISP(1)
      IBEG=IDISP(1)
      IF (LP.NE.0) WRITE(LP,310)
      IFLAG=-5
      IF (ABORT3) GO TO 1030
      IF (IACTIV-IBEG.GE.LENR(IPIV)) GO TO 550
C THERE IS STILL NOT ENOUGH ROOM IN A/ICN.
      IFLAG=-4
      GO TO 1030
C COPY PIVOT ROW AND SET UP IQ ARRAY.
  550 IJPOS=0
      J1=IPTR(IPIV)
C
      DO 570 JJ=J1,OLDEND
      A(IBEG)=A(JJ)
      ICN(IBEG)=ICN(JJ)
      IF (IJPOS.NE.0) GO TO 560
      IF (ICN(JJ).EQ.JPIV) IJPOS=IBEG
      ICN(JJ)=0
      GO TO 570
  560 K=IBEG-IJPOS
      J=ICN(JJ)
      ICN(JJ)=IQ(J)
      IQ(J)=-K
  570 IBEG=IBEG+1
C
      IJP1=IJPOS+1
      PIVEND=IBEG-1
      LENPIV=PIVEND-IJPOS
      NZROW=NZROW-LENRL(IPIV)-1
      IPTR(IPIV)=OLDPIV+1
      IF (LENPIV.EQ.0) IPTR(IPIV)=0
C
C REMOVE PIVOT ROW (INCLUDING PIVOT) FROM COLUMN ORIENTED FILE.
      DO 600 JJ=IJPOS,PIVEND
      J=ICN(JJ)
      I1=IPC(J)
      LENC(J)=LENC(J)-1
C I2 IS LAST POSITION IN NEW COLUMN.
      I2=IPC(J)+LENC(J)-1
      IF (I2.LT.I1) GO TO 590
      DO 580 II=I1,I2
      IF (IRN(II).NE.IPIV) GO TO 580
      IRN(II)=IRN(I2+1)
      GO TO 590
  580 CONTINUE
  590 IRN(I2+1)=0
  600 CONTINUE
      NZCOL=NZCOL-LENPIV-1
C
C GO DOWN THE PIVOT COLUMN AND FOR EACH ROW WITH A NON-ZERO ADD
C     THE APPROPRIATE MULTIPLE OF THE PIVOT ROW TO IT.
C WE LOOP ON THE NUMBER OF NON-ZEROS IN THE PIVOT COLUMN SINCE
C     MA30D MAY CHANGE ITS ACTUAL POSITION.
C
      NZPC=LENC(JPIV)
      IF (NZPC.EQ.0) GO TO 870
      DO 820 III=1,NZPC
      II=IPC(JPIV)+III-1
      I=IRN(II)
C SEARCH ROW I FOR NON-ZERO TO BE ELIMINATED, CALCULATE MULTIPLIER,
C     AND PLACE IT IN POSITION LENRL+1 IN ITS ROW.
      J1=IPTR(I)+LENRL(I)
      IEND=IPTR(I)+LENR(I)-1
      DO 610 JJ=J1,IEND
      IF (ICN(JJ).NE.JPIV) GO TO 610
C IF PIVOT IS ZERO, REST OF COLUMN IS AND SO MULTIPLIER IS ZERO.
      AU=ZERO
      IF (A(IJPOS).NE.ZERO) AU=-A(JJ)/A(IJPOS)
      A(JJ)=A(J1)
      A(J1)=AU
      ICN(JJ)=ICN(J1)
      ICN(J1)=JPIV
      LENRL(I)=LENRL(I)+1
      GO TO 620
  610 CONTINUE
C GO TO 870 IF PIVOT ROW IS A SINGLETON.
  620 IF (LENPIV.EQ.0) GO TO 820
C NOW PERFORM NECESSARY OPERATIONS ON REST OF NON-PIVOT ROW I.
      ROWI=J1+1
      IOP=0
C IF ALL THE PIVOT ROW CAUSES FILL-IN GO TO 640
      IF (ROWI.GT.IEND) GO TO 640
C PERFORM OPERATIONS ON CURRENT NON-ZEROS IN ROW I.
C INNERMOST LOOP.
      DO 630 JJ=ROWI,IEND
      J=ICN(JJ)
      IF (IQ(J).GT.0) GO TO 630
      IOP=IOP+1
      PIVROW=IJPOS-IQ(J)
      A(JJ)=A(JJ)+AU*A(PIVROW)
      ICN(PIVROW)=-ICN(PIVROW)
  630 CONTINUE
  640 IFILL=LENPIV-IOP
C IF THERE IS NO FILL-IN GO TO 740.
      IF (IFILL.EQ.0) GO TO 740
C NOW FOR THE FILL-IN.
      MINICN=MAX0(MINICN,MOREI+IBEG-1+NZROW+IFILL+LENR(I))
C SEE IF THERE IS ROOM FOR FILL-IN.
C GET MAXIMUM SPACE FOR ROW I IN SITU.
      DO 650 JDIFF=1,IFILL
      JNPOS=IEND+JDIFF
      IF (JNPOS.GT.LICN) GO TO 660
      IF (ICN(JNPOS).NE.0) GO TO 660
  650 CONTINUE
C THERE IS ROOM FOR ALL THE FILL-IN AFTER THE END OF THE ROW SO IT
C     CAN BE LEFT IN SITU.
C NEXT AVAILABLE SPACE FOR FILL-IN.
      IEND=IEND+1
      GO TO 740
C JMORE SPACES FOR FILL-IN ARE REQUIRED IN FRONT OF ROW.
  660 JMORE=IFILL-JDIFF+1
      I1=IPTR(I)
C WE NOW LOOK IN FRONT OF THE ROW TO SEE IF THERE IS SPACE FOR
C     THE REST OF THE FILL-IN.
      DO 670 JDIFF=1,JMORE
      JNPOS=I1-JDIFF
      IF (JNPOS.LT.IACTIV) GO TO 680
      IF (ICN(JNPOS).NE.0) GO TO 690
  670 CONTINUE
  680 JNPOS=I1-JMORE
      GO TO 700
C WHOLE ROW MUST BE MOVED TO THE BEGINNING OF AVAILABLE STORAGE.
  690 JNPOS=IACTIV-LENR(I)-IFILL
C IF THERE IS SPACE IMMEDIATELY AVAILABLE FOR THE SHIFTED ROW GO TO 720.
  700 IF (JNPOS.GE.IBEG) GO TO 720
      CALL MA30D(A,ICN,IPTR(ISTART),N,IACTIV,ITOP,.TRUE.)
      I1=IPTR(I)
      IEND=I1+LENR(I)-1
      JNPOS=IACTIV-LENR(I)-IFILL
      IF (JNPOS.GE.IBEG) GO TO 720
C NO SPACE AVAILABLE SO TRY TO CREATE SOME BY THROWING AWAY PREVIOUS
C     LU DECOMPOSITION.
      MOREI=MOREI+IBEG-IDISP(1)-LENPIV-1
      IF (LP.NE.0) WRITE(LP,310)
      IFLAG=-5
      IF (ABORT3) GO TO 1030
C KEEP RECORD OF CURRENT PIVOT ROW.
      IBEG=IDISP(1)
      ICN(IBEG)=JPIV
      A(IBEG)=A(IJPOS)
      IJPOS=IBEG
      DO 710 JJ=IJP1,PIVEND
      IBEG=IBEG+1
      A(IBEG)=A(JJ)
  710 ICN(IBEG)=ICN(JJ)
      IJP1=IJPOS+1
      PIVEND=IBEG
      IBEG=IBEG+1
      IF (JNPOS.GE.IBEG) GO TO 720
C THIS STILL DOES NOT GIVE ENOUGH ROOM.
      IFLAG=-4
      GO TO 1030
  720 IACTIV=MIN0(IACTIV,JNPOS)
C MOVE NON-PIVOT ROW I.
      IPTR(I)=JNPOS
      DO 730 JJ=I1,IEND
      A(JNPOS)=A(JJ)
      ICN(JNPOS)=ICN(JJ)
      JNPOS=JNPOS+1
  730 ICN(JJ)=0
C FIRST NEW AVAILABLE SPACE.
      IEND=JNPOS
  740 NZROW=NZROW+IFILL
C INNERMOST FILL-IN LOOP WHICH ALSO RESETS ICN.
      DO 810 JJ=IJP1,PIVEND
      J=ICN(JJ)
      IF (J.LT.0) GO TO 800
      A(IEND)=AU*A(JJ)
      ICN(IEND)=J
      IEND=IEND+1
C
C PUT NEW ENTRY IN COLUMN FILE.
      MINIRN=MAX0(MINIRN,NZCOL+LENC(J)+1)
      JEND=IPC(J)+LENC(J)
      JROOM=NZPC-III+1+LENC(J)
      IF (JEND.GT.LIRN) GO TO 750
      IF (IRN(JEND).EQ.0) GO TO 790
  750 IF (JROOM.LT.DISPC) GO TO 760
C COMPRESS COLUMN FILE TO OBTAIN SPACE FOR NEW COPY OF COLUMN.
      CALL MA30D(A,IRN,IPC(ISTART),N,DISPC,LIRN,.FALSE.)
      IF (JROOM.LT.DISPC) GO TO 760
      JROOM=DISPC-1
      IF (JROOM.GE.LENC(J)+1) GO TO 760
C COLUMN FILE IS NOT LARGE ENOUGH.
      GO TO 1050
C COPY COLUMN TO BEGINNING OF FILE.
  760 JBEG=IPC(J)
      JEND=IPC(J)+LENC(J)-1
      JZERO=DISPC-1
      DISPC=DISPC-JROOM
      IDISPC=DISPC
      DO 770 II=JBEG,JEND
      IRN(IDISPC)=IRN(II)
      IRN(II)=0
  770 IDISPC=IDISPC+1
      IPC(J)=DISPC
      JEND=IDISPC
      DO 780 II=JEND,JZERO
  780 IRN(II)=0
  790 IRN(JEND)=I
      NZCOL=NZCOL+1
      LENC(J)=LENC(J)+1
C END OF ADJUSTMENT TO COLUMN FILE.
      GO TO 810
C
  800 ICN(JJ)=-J
  810 CONTINUE
      LENR(I)=LENR(I)+IFILL
C END OF SCAN OF PIVOT COLUMN.
  820 CONTINUE
C
C
C REMOVE PIVOT COLUMN FROM COLUMN ORIENTED STORAGE AND UPDATE ROW
C     ORDERING ARRAYS.
      I1=IPC(JPIV)
      I2=IPC(JPIV)+LENC(JPIV)-1
      NZCOL=NZCOL-LENC(JPIV)
      DO 860 II=I1,I2
      I=IRN(II)
      IRN(II)=0
      NZ=LENR(I)-LENRL(I)
      IF (NZ.NE.0) GO TO 830
      LASTR(I)=0
      GO TO 860
  830 IFIR=IFIRST(NZ)
      IFIRST(NZ)=I
      IF (IFIR) 840,855,850
  840 LASTR(I)=IFIR
      NEXTR(I)=0
      GO TO 860
  850 LASTR(I)=LASTR(IFIR)
      NEXTR(I)=IFIR
      LASTR(IFIR)=I
      GO TO 860
  855 LASTR(I)=0
      NEXTR(I)=0
      NZMIN=MIN0(NZMIN,NZ)
  860 CONTINUE
C RESTORE IQ AND NULLIFY U PART OF OLD PIVOT ROW.
  870 IPC(JPIV)=0
      IF (LENPIV.EQ.0) GO TO 930
      NZROW=NZROW-LENPIV
      JVAL=IJP1
      JZER=IPTR(IPIV)
      IPTR(IPIV)=0
      DO 880 JCOUNT=1,LENPIV
      J=ICN(JVAL)
      IQ(J)=ICN(JZER)
      ICN(JZER)=0
      JVAL=JVAL+1
  880 JZER=JZER+1
C ADJUST COLUMN ORDERING ARRAYS.
      DO 920 JJ=IJP1,PIVEND
      J=ICN(JJ)
      NZ=LENC(J)
      IF (NZ.NE.0) GO TO 890
      LASTC(J)=0
      GO TO 920
  890 IFIR=IFIRST(NZ)
      LASTC(J)=0
      IF (IFIR) 900,910,915
  900 IFIRST(NZ)=-J
      IFIR=-IFIR
      LASTC(IFIR)=J
      NEXTC(J)=IFIR
      GO TO 920
  910 IFIRST(NZ)=-J
      NEXTC(J)=0
      NZMIN=MIN0(NZMIN,NZ)
      GO TO 920
  915 LC=-LASTR(IFIR)
      LASTR(IFIR)=-J
      NEXTC(J)=LC
      IF (LC.NE.0) LASTC(LC)=J
  920 CONTINUE
  930 CONTINUE
C ********************************************
C ****    END OF MAIN ELIMINATION LOOP    ****
C ********************************************
C
C RESET IACTIV TO POINT TO THE BEGINNING OF THE NEXT BLOCK.
  940 IF (ILAST.NE.NN) IACTIV=IPTR(ILAST+1)
  950 CONTINUE
C
C ********************************************
C ****    END OF DEOMPOSITION OF BLOCK    ****
C ********************************************
C
C RECORD SINGULARITY (IF ANY) IN IQ ARRAY.
      IF (IRANK.EQ.NN) GO TO 970
      DO 960 I=1,NN
      IF (LASTC(I).GT.0) GO TO 960
      ISING=-LASTC(I)
      IQ(ISING)=-IQ(ISING)
      LASTC(I)=ISING
  960 CONTINUE
C
C RUN THROUGH LU DECOMPOSITION CHANGING COLUMN INDICES TO THAT OF NEW
C     ORDER AND PERMUTING LENR AND LENRL ARRAYS ACCORDING TO PIVOT
C     PERMUTATIONS.
  970 ISTART=IDISP(1)
      IEND=IBEG-1
      DO 980 JJ=ISTART,IEND
      JOLD=ICN(JJ)
  980 ICN(JJ)=LASTC(JOLD)
      DO 990 II=1,NN
      I=LASTR(II)
      NEXTR(I)=LENR(II)
  990 NEXTC(I)=LENRL(II)
      DO 1000 I=1,NN
      LENRL(I)=NEXTC(I)
 1000 LENR(I)=NEXTR(I)
C
C UPDATE PERMUTATION ARRAYS IP AND IQ.
      DO 1010 II=1,NN
      I=LASTR(II)
      J=LASTC(II)
      NEXTR(I)=IABS(IP(II)+0)
 1010 NEXTC(J)=IABS(IQ(II)+0)
      DO 1020 I=1,NN
      IF (IP(I).LT.0) NEXTR(I)=-NEXTR(I)
      IP(I)=NEXTR(I)
      IF (IQ(I).LT.0) NEXTC(I)=-NEXTC(I)
 1020 IQ(I)=NEXTC(I)
      IP(NN)=IABS(IP(NN)+0)
      IDISP(2)=IEND
      GO TO 1110
C
C   ***    ERROR RETURNS    ***
 1030 IDISP(2)=IACTIV
      IF (LP.EQ.0) GO TO 1110
      WRITE(LP,1040)
 1040 FORMAT(' ERROR RETURN FROM MA30A BECAUSE LICN NOT BIG ENOUGH')
      GO TO 1080
 1050 IF (IFLAG.EQ.-5) IFLAG=-6
      IF (IFLAG.NE.-6) IFLAG=-3
      IDISP(2)=IACTIV
      IF (LP.EQ.0) GO TO 1110
      IF (IFLAG.EQ.-3) WRITE(LP,1060)
      IF (IFLAG.EQ.-6) WRITE(LP,1070)
 1060 FORMAT(' ERROR RETURN FROM MA30A BECAUSE LIRN NOT BIG ENOUGH')
 1070 FORMAT(' ERROR RETURN FROM MA30A LIRN AND LICN TOO SMALL')
 1080 PIVOT=PIVOT-ISTART+1
      WRITE(LP,1090) PIVOT,NBLOCK,ISTART,ILAST
 1090 FORMAT(' AT STAGE ',I5,' IN BLOCK ',I5,
     $   ' WITH FIRST ROW ',I5,' AND LAST ROW ',I5)
      IF (PIVOT.EQ.0) WRITE(LP,1100) MINIRN
 1100 FORMAT(' TO CONTINUE SET LIRN TO AT LEAST ',I8)
 1110 RETURN
      END
C
C
C
      SUBROUTINE MA30D(A,ICN,IPTR,N,IACTIV,ITOP,REALS)
      DIMENSION A(ITOP),IPTR(N),ICN(ITOP)
      LOGICAL REALS
C IACTIV IS THE FIRST POSITION IN ARRAYS A/ICN FROM WHICH THE
C     COMPRESS STARTS.
C ON EXIT IACTIV EQUALS THE POSITION OF THE FIRST ELEMENT IN THE
C     COMPRESSED PART OF A/ICN
      COMMON /MA30F/ IRNCP,ICNCP,IRANK,MINIRN,MINICN
      IF (REALS) ICNCP=ICNCP+1
      IF (.NOT.REALS) IRNCP=IRNCP+1
C SET THE FIRST NON-ZERO ELEMENT IN EACH ROW TO THE NEGATIVE OF THE
C     ROW/COL NUMBER AND HOLD THIS ROW/COL INDEX IN THE ROW/COL
C     POINTER.  THIS IS SO THAT THE BEGINNING OF EACH ROW/COL CAN
C     BE RECOGNIZED IN THE SUBSEQUENT SCAN.
      DO 10 J=1,N
      K=IPTR(J)
      IF (K.LT.IACTIV) GO TO 10
      IPTR(J)=ICN(K)
      ICN(K)=-J
   10 CONTINUE
      KN=ITOP+1
      KL=ITOP-IACTIV+1
C GO THROUGH ARRAYS IN REVERSE ORDER COMPRESSING TO THE BACK SO
C     THAT THERE ARE NO ZEROS HELD IN POSITIONS IACTIV TO ITOP IN ICN.
C     RESET FIRST ELEMENT OF EACH ROW/COL AND POINTER ARRAY IPTR.
      DO 30 K=1,KL
      JPOS=ITOP-K+1
      IF (ICN(JPOS).EQ.0) GO TO 30
      KN=KN-1
      IF (REALS) A(KN)=A(JPOS)
      IF (ICN(JPOS).GE.0) GO TO 20
C FIRST NON-ZERO OF ROW/COL HAS BEEN LOCATED
      J=-ICN(JPOS)
      ICN(JPOS)=IPTR(J)
      IPTR(J)=KN
   20 ICN(KN)=ICN(JPOS)
   30 CONTINUE
      IACTIV=KN
      RETURN
      END
C
C
C
      SUBROUTINE MA30B (N,ICN,A,LICN,LENR,LENRL,IDISP,IP,IQ,W,IW,
     $                 IFLAG)
      DIMENSION A(LICN),W(N),IW(N),IDISP(2),ICN(LICN),LENR(N),LENRL(N),
     $          IP(N),IQ(N)
      INTEGER PIVPOS
      LOGICAL ABORT1,ABORT2,ABORT3,STAB
      COMMON /MA30E/ LP,ABORT1,ABORT2,ABORT3
      COMMON /MA30G/ EPS,RMIN
      DATA ZERO/0.0/,ONE/1.0/
      STAB=EPS.LE.ONE
      RMIN=EPS
      ISING=0
      IFLAG=0
C 170 = RETURN...
      IF (N.EQ.1) GO TO 170
      DO 10 I=1,N
   10 W(I)=ZERO
C SET UP POINTERS TO THE BEGINNING OF THE ROWS.
      IW(1)=IDISP(1)
      DO 20 I=2,N
   20 IW(I)=IW(I-1)+LENR(I-1)
C
C   ****   START  OF MAIN LOOP    ****
C AT STEP I, ROW I OF A IS TRANSFORMED TO ROW I OF L/U BY ADDING
C     APPROPRIATE MULTIPLES OF ROWS 1 TO I-1.
C     .... USING ROW-GAUSS ELIMINATION.
      DO 140 I=1,N
C ISTART IS BEGINNING OF ROW I OF A AND ROW I OF L.
      ISTART=IW(I)
C IFIN IS END OF ROW I OF A AND ROW I OF U.
      IFIN=ISTART+LENR(I)-1
C ILEND IS END OF ROW I OF L.
      ILEND=ISTART+LENRL(I)-1
      IF (ISTART.GT.ILEND) GO TO 70
C LOAD ROW I OF A INTO VECTOR W.
      DO 30 JJ=ISTART,IFIN
      J=ICN(JJ)
   30 W(J)=A(JJ)
C
C ADD MULTIPLES OF APPROPRIATE ROWS OF  I TO I-1  TO ROW I.
      DO 50 JJ=ISTART,ILEND
      J=ICN(JJ)
C IPIVJ IS POSITION OF PIVOT IN ROW J.
      IPIVJ=IW(J)+LENRL(J)
C FORM MULTIPLIER AU.
      AU=-W(J)/A(IPIVJ)
      W(J)=AU
C AU * ROW J (U PART) IS ADDED TO ROW I.
      IPIVJ=IPIVJ+1
      JFIN=IW(J)+LENR(J)-1
      IF (IPIVJ.GT.JFIN) GO TO 50
C INNERMOST LOOP.
      DO 40 JAYJAY=IPIVJ,JFIN
      JAY=ICN(JAYJAY)
   40 W(JAY)=W(JAY)+AU*A(JAYJAY)
C
   50 CONTINUE
C RELOAD W BACK INTO A (NOW L/U)
      DO 60 JJ=ISTART,IFIN
      J=ICN(JJ)
      A(JJ)=W(J)
   60 W(J)=ZERO
C WE NOW PERFORM THE STABILITY CHECKS.
   70 PIVPOS=ILEND+1
      IF (IQ(I).GT.0) GO TO 120
C MATRIX HAD SINGULARITY AT THIS POINT IN MA30A.
C IS IT THE FIRST SUCH PIVOT IN CURRENT BLOCK ?
      IF (ISING.EQ.0) ISING=I
C DOES CURRENT MATRIX HAVE A SINGULARITY IN THE SAME PLACE ?
      IF (PIVPOS.GT.IFIN) GO TO 80
      IF (A(PIVPOS).NE.ZERO) GO TO 150
C IT DOES .. SO SET ISING IF IT IS NOT THE END OF THE CURRENT BLOCK
C CHECK TO SEE THAT APPROPRIATE PART OF L/U IS ZERO OR NULL.
   80 IF (ISTART.GT.IFIN) GO TO 100
      DO 90 JJ=ISTART,IFIN
      IF (ICN(JJ).LT.ISING) GO TO 90
      IF (A(JJ).NE.ZERO) GO TO 150
   90 CONTINUE
  100 IF (PIVPOS.LE.IFIN) A(PIVPOS)=ONE
      IF (IP(I).GT.0.AND.I.NE.N) GO TO 140
C END OF CURRENT BLOCK ... RESET ZERO PIVOTS AND ISING.
      DO 110 J=ISING,I
      IF ((LENR(J)-LENRL(J)).EQ.0) GO TO 110
      JJ=IW(J)+LENRL(J)
      A(JJ)=ZERO
  110 CONTINUE
      ISING=0
      GO TO 140
C MATRIX HAD NON-ZERO PIVOT IN MA30A AT THIS STAGE.
  120 IF (PIVPOS.GT.IFIN) GO TO 150
      IF (A(PIVPOS).EQ.ZERO) GO TO 150
      IF (.NOT.STAB) GO TO 140
      ROWMAX=ZERO
      DO 130 JJ=PIVPOS,IFIN
  130 ROWMAX=AMAX1(ROWMAX,ABS(A(JJ)))
      IF (ABS(A(PIVPOS))/ROWMAX.GE.RMIN) GO TO 140
      IFLAG=I
C   ****    END OF MAIN LOOP    ****
      RMIN=ABS(A(PIVPOS))/ROWMAX
  140 CONTINUE
C
      GO TO 170
C   ***   ERROR RETURN   ***
  150 IF (LP.NE.0) WRITE(LP,160) I
  160 FORMAT(' ERROR RETURN FROM MA30B SINGULARITY DETECTED IN ROW',I8)
      IFLAG=-I
C
  170 RETURN
      END
C
C
C
      SUBROUTINE MA30C (N,ICN,A,LICN,LENR,LENRL,LENOFF,IDISP,IP,IQ,
     $                  X,W,MTYPE)
      DIMENSION A(LICN),X(N),W(N),IDISP(2),ICN(LICN),LENR(N),LENRL(N),
     $          LENOFF(N),IP(N),IQ(N)
      LOGICAL NEG,NOBLOC
      COMMON /MA30H/ RESID
C THE FINAL VALUE OF RESID IS THE MAXIMUM RESIDUAL FOR AN INCONSISTENT
C     SET OF EQUATIONS.
      DATA ZERO/0.0/
      RESID=ZERO
C NOBLOC IS .TRUE. IF SUBROUTINE BLOCK HAS BEEN USED PREVIOUSLY AND
C     IS .FALSE. OTHERWISE.  THE VALUE .FALSE. MEANS THAT LENOFF
C     WILL NOT BE SUBSEQUENTLY ACCESSED.
      NOBLOC=LENOFF(1).LT.0
      IF (MTYPE.NE.1) GO TO 140
C
C WE NOW SOLVE   A * X = B.
C NEG IS USED TO INDICATE WHEN THE LAST ROW IN A BLOCK HAS BEEN
C     REACHED.  IT IS THEN SET TO TRUE WHEREAFTER BACKSUBSTITUTION IS
C     PERFORMED ON THE BLOCK.
      NEG=.FALSE.
C IP(N) IS NEGATED SO THAT THE LAST ROW OF THE LAST BLOCK CAN BE
C     RECOGNISED.  IT IS RESET TO ITS POSITIVE VALUE ON EXIT.
      IP(N)=-IP(N)
C PREORDER VECTOR ... W(I) = X(IP(I))
      DO 10 II=1,N
      I=IP(II)
      I=IABS(I)
   10 W(II)=X(I)
C LT HOLDS THE POSITION OF THE FIRST NON-ZERO IN THE CURRENT ROW OF THE
C     OFF-DIAGONAL BLOCKS.
      LT=1
C IFIRST HOLDS THE INDEX OF THE FIRST ROW IN THE CURRENT BLOCK.
      IFIRST=1
C IBLOCK HOLDS THE POSITION OF THE FIRST NON-ZERO IN THE CURRENT ROW
C     OF THE LU DECOMPOSITION OF THE DIAGONAL BLOCKS.
      IBLOCK=IDISP(1)
C IF I IS NOT THE LAST ROW OF A BLOCK, THEN A PASS THROUGH THIS LOOP
C     ADDS THE INNER PRODUCT OF ROW I OF THE OFF-DIAGONAL BLOCKS AND W
C     TO W AND PERFORMS FORWARD ELIMINATION USING ROW I OF THE LU
C     DECOMPOSITION.   IF I IS THE LAST ROW OF A BLOCK THEN, AFTER
C     PERFORMING THESE AFOREMENTIONED OPERATIONS, BACKSUBSTITUTION IS
C     PERFORMED USING THE ROWS OF THE BLOCK.
      DO 120 I=1,N
      WI=W(I)
      IF(NOBLOC)GO TO 30
      IF (LENOFF(I).EQ.0) GO TO 30
C OPERATIONS USING LOWER TRIANGULAR BLOCKS.
C LTEND IS THE END OF ROW I IN THE OFF-DIAGONAL BLOCKS.
      LTEND=LT+LENOFF(I)-1
      DO 20 JJ=LT,LTEND
      J=ICN(JJ)
   20 WI=WI-A(JJ)*W(J)
C LT IS SET THE BEGINNING OF THE NEXT OFF-DIAGONAL ROW.
      LT=LTEND+1
C SET NEG TO .TRUE. IF WE ARE ON THE LAST ROW OF THE BLOCK.
   30 IF (IP(I).LT.0) NEG=.TRUE.
      IF (LENRL(I).EQ.0) GO TO 50
C FORWARD ELIMINATION PHASE.
C IEND IS THE END OF THE L PART OF ROW I IN THE LU DECOMPOSITION.
      IEND=IBLOCK+LENRL(I)-1
      DO 40 JJ=IBLOCK,IEND
      J=ICN(JJ)
   40 WI=WI+A(JJ)*W(J)
C IBLOCK IS ADJUSTED TO POINT TO THE START OF THE NEXT ROW.
   50 IBLOCK=IBLOCK+LENR(I)
      W(I)=WI
      IF (.NOT.NEG) GO TO 120
C BACK SUBSTITUTION PHASE.
C J1 IS POSITION IN A/ICN AFTER END OF BLOCK BEGINNING IN ROW IFIRST
C     AND ENDING IN ROW I.
      J1=IBLOCK
C ARE THERE ANY SINGULARITIES IN THIS BLOCK?  IF NOT, CONTINUE WITH
C     THE BACKSUBSTITUTION.
      IB=I
      IF (IQ(I).GT.0) GO TO 70
      DO 60 III=IFIRST,I
      IB=I-III+IFIRST
      IF (IQ(IB).GT.0) GO TO 70
      J1=J1-LENR(IB)
      RESID=AMAX1(RESID,ABS(W(IB)))
      W(IB)=ZERO
   60 CONTINUE
C ENTIRE BLOCK IS SINGULAR.
      GO TO 110
C EACH PASS THROUGH THIS LOOP PERFORMS THE BACK-SUBSTITUTION
C     OPERATIONS FOR A SINGLE ROW, STARTING AT THE END OF THE BLOCK AND
C     WORKING THROUGH IT IN REVERSE ORDER.
   70 DO 100 III=IFIRST,IB
      II=IB-III+IFIRST
C J2 IS END OF ROW II.
      J2=J1-1
C J1 IS BEGINNING OF ROW II.
      J1=J1-LENR(II)
C JPIV IS THE POSITION OF THE PIVOT IN ROW II.
      JPIV=J1+LENRL(II)
      JPIVP1=JPIV+1
C IF ROW  II OF U HAS NO NON-ZEROS GO TO 90.
      IF (J2.LT.JPIVP1) GO TO 90
      WII=W(II)
      DO 80 JJ=JPIVP1,J2
      J=ICN(JJ)
   80 WII=WII-A(JJ)*W(J)
      W(II)=WII
   90 W(II)=W(II)/A(JPIV)
  100 CONTINUE
  110 IFIRST=I+1
      NEG=.FALSE.
  120 CONTINUE
C
C REORDER SOLUTION VECTOR ... X(I) = W(IQINVERSE(I))
      DO 130 II=1,N
      I=IQ(II)
      I=IABS(I)
  130 X(I)=W(II)
      IP(N)=-IP(N)
      GO TO 310
C
C WE NOW SOLVE   ATRANSPOSE * X = B.
C PREORDER VECTOR ... W(I)=X(IQ(I))
  140 DO 150 II=1,N
      I=IQ(II)
      I=IABS(I)
  150 W(II)=X(I)
C LJ1 POINTS TO THE BEGINNING THE CURRENT ROW IN THE OFF-DIAGONAL
C     BLOCKS.
      LJ1=IDISP(1)
C IBLOCK IS INITIALIZED TO POINT TO THE BEGINNING OF THE BLOCK AFTER
C     THE LAST ONE !
      IBLOCK=IDISP(2)+1
C ILAST IS THE LAST ROW IN THE CURRENT BLOCK.
      ILAST=N
C IBLEND POINTS TO THE POSITION AFTER THE LAST NON-ZERO IN THE
C     CURRENT BLOCK.
      IBLEND=IBLOCK
C EACH PASS THROUGH THIS LOOP OPERATES WITH ONE DIAGONAL BLOCK AND
C     THE OFF-DIAGONAL PART OF THE MATRIX CORRESPONDING TO THE ROWS
C     OF THIS BLOCK.  THE BLOCKS ARE TAKEN IN REVERSE ORDER AND THE
C     NUMBER OF TIMES THE LOOP IS ENTERED IS MIN(N,NO. BLOCKS+1).
      DO 280 NUMBLK=1,N
      IF (ILAST.EQ.0) GO TO 290
      IBLOCK=IBLOCK-LENR(ILAST)
C THIS LOOP FINDS THE INDEX OF THE FIRST ROW IN THE CURRENT BLOCK..
C     IT IS FIRST AND IBLOCK IS SET TO THE POSITION OF THE BEGINNING
C     OF THIS FIRST ROW.
      DO 160 K=1,N
      II=ILAST-K
      IF (II.EQ.0) GO TO 170
      IF (IP(II).LT.0) GO TO 170
      IBLOCK=IBLOCK-LENR(II)
  160 CONTINUE
  170 IFIRST=II+1
C J1 POINTS TO THE POSITION OF THE BEGINNING OF ROW I (LT PART) OR PIVOT
      J1=IBLOCK
C FORWARD ELIMINATION.
C EACH PASS THROUGH THIS LOOP PERFORMS THE OPERATIONS FOR ONE ROW OF THE
C     BLOCK.  IF THE CORRESPONDING ELEMENT OF W IS ZERO THEN THE
C     OPERATIONS CAN BE AVOIDED.
      DO 200 I=IFIRST,ILAST
      IF (W(I).EQ.ZERO) GO TO 195
C IS ROW I SINGULAR?  IF SO, GO TO 210
      IF (IQ(I).LT.0) GO TO 210
C J2 FIRST POINTS TO THE PIVOT IN ROW I AND THEN IS MADE TO POINT TO THE
C     FIRST NON-ZERO IN THE U TRANSPOSE PART OF THE ROW.
      J2=J1+LENRL(I)
      WI=W(I)/A(J2)
      IF (LENR(I)-LENRL(I).EQ.1) GO TO 190
      J2=J2+1
C J3 POINTS TO THE END OF ROW I.
      J3=J1+LENR(I)-1
      DO 180 JJ=J2,J3
      J=ICN(JJ)
  180 W(J)=W(J)-A(JJ)*WI
  190 W(I)=WI
  195 J1=J1+LENR(I)
  200 CONTINUE
      GO TO 230
C DEALS WITH REST OF BLOCK WHICH IS SINGULAR.
  210 DO 220 II=I,ILAST
      RESID=AMAX1(RESID,ABS(W(II)))
      W(II)=ZERO
  220 CONTINUE
C BACK SUBSTITUTION.
C THIS LOOP DOES THE BACK SUBSTITUTION ON THE ROWS OF THE BLOCK IN
C     THE REVERSE ORDER DOING IT SIMULTANEOUSLY ON THE L TRANSPOSE PART
C     OF THE DIAGONAL BLOCKS AND THE OFF-DIAGONAL BLOCKS.
  230 J1=IBLEND
      DO 270 IBACK=IFIRST,ILAST
      I=ILAST-IBACK+IFIRST
C J1 POINTS TO THE BEGINNING OF ROW I.
      J1=J1-LENR(I)
      IF (LENRL(I).EQ.0) GO TO 250
C J2 POINTS TO THE END OF THE L TRANSPOSE PART OF ROW I.
      J2=J1+LENRL(I)-1
      DO 240 JJ=J1,J2
      J=ICN(JJ)
  240 W(J)=W(J)+A(JJ)*W(I)
  250 IF(NOBLOC)GO TO 270
C OPERATIONS USING LOWER TRIANGULAR BLOCKS.
      IF(LENOFF(I).EQ.0)GO TO 270
C LJ2 POINTS TO THE END OF ROW I OF THE OFF-DIAGONAL BLOCKS.
      LJ2=LJ1-1
C LJ1 POINTS TO THE BEGINNING OF ROW I OF THE OFF-DIAGONAL BLOCKS.
      LJ1=LJ1-LENOFF(I)
      DO 260 JJ=LJ1,LJ2
      J=ICN(JJ)
  260 W(J)=W(J)-A(JJ)*W(I)
  270 CONTINUE
      IBLEND=J1
      ILAST=IFIRST-1
  280 CONTINUE
C REORDER SOLUTION VECTOR ... X(I)=W(IPINVERSE(I))
  290 DO 300 II=1,N
      I=IP(II)
      I=IABS(I)
  300 X(I)=W(II)
C
  310 RETURN
      END
C
C
C
      SUBROUTINE MC21A(N,ICN,LICN,IP,LENR,IPERM,NUMNZ,IW)
      DIMENSION IP(N),ICN(LICN),LENR(N),IPERM(N),IW(N,4)
      CALL MC21B(N,ICN,LICN,IP,LENR,IPERM,NUMNZ,
     $          IW(1,1),IW(1,2),IW(1,3),IW(1,4))
      RETURN
      END
C
C
C
      SUBROUTINE MC21B(N,ICN,LICN,IP,LENR,IPERM,NUMNZ,PR,ARP,CV,OUT)
      DIMENSION IP(N),ICN(LICN),LENR(N),IPERM(N)
      INTEGER PR(N),CV(N),ARP(N),OUT(N)
C   PR(I) IS THE PREVIOUS ROW TO I IN THE DEPTH FIRST SEARCH.
C IT IS USED AS A WORK ARRAY IN THE SORTING ALGORITHM.
C   ELEMENTS (IPERM(I),I) I=1, ... N  ARE NON-ZERO AT THE END OF THE
C ALGORITHM UNLESS N ASSIGNMENTS HAVE NOT BEEN MADE.  IN WHICH CASE
C (IPERM(I),I) WILL BE ZERO FOR N-NUMNZ ENTRIES.
C   CV(I) IS THE MOST RECENT ROW EXTENSION AT WHICH COLUMN I
C WAS VISITED.
C   ARP(I) IS ONE LESS THAN THE NUMBER OF NON-ZEROS IN ROW I
C WHICH HAVE NOT BEEN SCANNED WHEN LOOKING FOR A CHEAP ASSIGNMENT.
C   OUT(I) IS ONE LESS THAN THE NUMBER OF NON-ZEROS IN ROW I
C WHICH HAVE NOT BEEN SCANNED DURING ONE PASS THROUGH THE MAIN LOOP.
C
C   INITIALIZATION OF ARRAYS.
      DO 10 I=1,N
      ARP(I)=LENR(I)-1
      CV(I)=0
   10 IPERM(I)=0
      NUMNZ=0
C
C
C   MAIN LOOP.
C   EACH PASS ROUND THIS LOOP EITHER RESULTS IN A NEW ASSIGNMENT
C OR GIVES A ROW WITH NO ASSIGNMENT.
      DO 130 JORD=1,N
      J=JORD
      PR(J)=-1
      DO 100 K=1,JORD
C LOOK FOR A CHEAP ASSIGNMENT
      IN1=ARP(J)
      IF (IN1.LT.0) GO TO 60
      IN2=IP(J)+LENR(J)-1
      IN1=IN2-IN1
      DO 50 II=IN1,IN2
      I=ICN(II)
      IF (IPERM(I).EQ.0) GO TO 110
   50 CONTINUE
C   NO CHEAP ASSIGNMENT IN ROW.
      ARP(J)=-1
C   BEGIN LOOKING FOR ASSIGNMENT CHAIN STARTING WITH ROW J.
   60 OUT(J)=LENR(J)-1
C INNER LOOP.  EXTENDS CHAIN BY ONE OR BACKTRACKS.
      DO 90 KK=1,JORD
      IN1=OUT(J)
      IF (IN1.LT.0) GO TO 80
      IN2=IP(J)+LENR(J)-1
      IN1=IN2-IN1
C FORWARD SCAN.
      DO 70 II=IN1,IN2
      I=ICN(II)
      IF (CV(I).EQ.JORD) GO TO 70
C   COLUMN I HAS NOT YET BEEN ACCESSED DURING THIS PASS.
      J1=J
      J=IPERM(I)
      CV(I)=JORD
      PR(J)=J1
      OUT(J1)=IN2-II-1
      GO TO 100
   70 CONTINUE
C
C   BACKTRACKING STEP.
   80 J=PR(J)
      IF (J.EQ.-1) GO TO 130
   90 CONTINUE
C
  100 CONTINUE
C
C   NEW ASSIGNMENT IS MADE.
  110 IPERM(I)=J
      ARP(J)=IN2-II-1
      NUMNZ=NUMNZ+1
      DO 120 K=1,JORD
      J=PR(J)
      IF (J.EQ.-1) GO TO 130
      II=IP(J)+LENR(J)-OUT(J)-2
      I=ICN(II)
      IPERM(I)=J
  120 CONTINUE
C
  130 CONTINUE
C
C   IF MATRIX IS STRUCTURALLY SINGULAR, WE NOW COMPLETE THE
C PERMUTATION IPERM.
      IF (NUMNZ.EQ.N) RETURN
      DO 140 I=1,N
  140 ARP(I)=0
      K=0
      DO 160 I=1,N
      IF (IPERM(I).NE.0) GO TO 150
      K=K+1
      OUT(K)=I
      GO TO 160
  150 J=IPERM(I)
      ARP(J)=I
  160 CONTINUE
      K=0
      DO 170 I=1,N
      IF (ARP(I).NE.0) GO TO 170
      K=K+1
      IOUTK=OUT(K)
      IPERM(IOUTK)=I
  170 CONTINUE
      RETURN
      END
C
C
C
      SUBROUTINE MC19A (N,NA,A,IRN,ICN,R,C,W)
      DIMENSION A(NA)
C      IRN(K) GIVES ROW NUMBER OF ELEMENT IN A(K).
C      ICN(K) GIVES COL NUMBER OF ELEMENT IN A(K).
      DIMENSION   IRN(NA),ICN(NA)
      DIMENSION R(N),C(N),W(N,5)
C      R(I) IS USED TO RETURN LOG(SCALING FACTOR FOR ROW I).
C      C(J) IS USED TO RETURN LOG(SCALING FACTOR FOR COL J).
C      W(I,1),  W(I,2) HOLD ROW, COL NON-ZERO COUNTS.
C      W(J,3) HOLDS - COL J LOG DURING EXECUTION.
C      W(J,4) HOLDS 2-ITERATION CHANGE IN W(J,3).
C      W(I,5) IS USED TO SAVE AVERAGE ELEMENT LOG FOR ROW I.
      COMMON /MC19B/ LP,IFAIL
      DATA MAXIT/100/,SMIN/0.1/
C MAXIT IS THE MAXIMAL PERMITTED NUMBER OF ITERATIONS
C     SMIN IS USED IN A CONVERGENCE TEST ON (RESIDUAL NORM)**2
C
C CHECK SCALAR DATA
      IFAIL=1
      IF(N.LT.1)GO TO 230
      IFAIL=0
C
C     INITIALISE FOR ACCUMULATION OF SUMS AND PRODUCTS
      DO 5 I=1,N
      C(I)=0.
      R(I)=0.
    5 CONTINUE
      DO 10 L=1,4
      DO 10 I=1,N
      W(I,L)=0.
   10 CONTINUE
      IF(NA.LE.0)GO TO 250
      DO 30 K=1,NA
      U=ABS(A(K))
      IF(U.EQ.0.)GO TO 30
      U=ALOG(U)
      I1=IRN(K)
      I2=ICN(K)
      IF(I1.GE.1 .AND. I1.LE.N .AND. I2.GE.1 .AND. I2.LE.N)GO TO 20
      IF(LP.GT.0)WRITE(LP,15)K,I1,I2
   15 FORMAT(' MC19 ERROR. ELEMENT',I5,' IS IN ROW',I5,
     $   ' AND COL',I5)
      IFAIL=3
      GO TO 30
C     COUNT ROW/COL NON-ZEROS, AND COMPUTE RHS VECTORS.
   20 W(I1,1)=W(I1,1)+1.
      W(I2,2)=W(I2,2)+1.
      R(I1)=R(I1)+U
      W(I2,3)=W(I2,3)+U
   30 CONTINUE
      IF(IFAIL.EQ.3)GO TO 230
C
C     DIVIDE RHS BY DIAG MATRICES
      DO 70 I=1,N
      IF(W(I,1).EQ.0.)W(I,1)=1.
      R(I)=R(I)/W(I,1)
C     SAVE R(I) FOR USE AT END.
      W(I,5)=R(I)
      IF(W(I,2).EQ.0.)W(I,2)=1.
      W(I,3)=W(I,3)/W(I,2)
   70 CONTINUE
      SM=SMIN*FLOAT(NA)
C     SWEEP TO COMPUTE INITIAL RESIDUAL VECTOR
      DO 80 K=1,NA
       IF(A(K).EQ.0.0 )GO TO 80
      I=IRN(K)
      J=ICN(K)
      R(I)=R(I)-W(J,3)/W(I,1)
   80 CONTINUE
C
C     INITIALISE ITERATION
      E=0.
      Q=1.
      S=0.
      DO 100 I=1,N
      S=S+W(I,1)*R(I)**2
  100 CONTINUE
      IF(S.LE.SM)GO TO 186
C
C     ITERATION LOOP
      DO 185 ITER=1,MAXIT
C    SWEEP THROUGH MATRIX TO UPDATE RESIDUAL VECTOR
      DO 130 K=1,NA
      IF(A(K).EQ.0.)GO TO 130
      I=ICN(K)
      J=IRN(K)
      C(I)=C(I)+R(J)
  130 CONTINUE
      S1=S
      S=0.
      DO 140 I=1,N
      V=-C(I)/Q
      C(I)=V/W(I,2)
      S=S+V*C(I)
  140 CONTINUE
      E1=E
      E=Q*S/S1
      Q=1.-E
      IF(S.LE.SM)E=0.
C     UPDATE RESIDUAL.
      DO 150 I=1,N
      R(I)=R(I)*E*W(I,1)
  150 CONTINUE
      IF(S.LE.SM)GO TO 190
      EM=E*E1
C    SWEEP THROUGH MATRIX TO UPDATE RESIDUAL VECTOR
      DO 152 K=1,NA
      IF(A(K).EQ.0.0 ) GO TO 152
      I=IRN(K)
      J=ICN(K)
      R(I)=R(I)+C(J)
  152 CONTINUE
      S1=S
      S=0.
      DO 155 I=1,N
      V=-R(I)/Q
      R(I)=V/W(I,1)
      S=S+V*R(I)
  155 CONTINUE
      E1=E
      E=Q*S/S1
      Q1=Q
      Q=1.-E
C     SPECIAL FIXUP FOR LAST ITERATION.
      IF(S.LE.SM)Q=1.
C     UPDATE COL. SCALING POWERS
      QM=Q*Q1
      DO 160 I=1,N
      W(I,4)=(EM*W(I,4)+C(I))/QM
      W(I,3)=W(I,3)+W(I,4)
  160 CONTINUE
      IF(S.LE.SM)GO TO 186
C     UPDATE RESIDUAL.
      DO 180 I=1,N
      C(I)=C(I)*E*W(I,2)
  180 CONTINUE
  185 CONTINUE
  186 DO 188 I=1,N
      R(I)=R(I)*W(I,1)
  188 CONTINUE
C
C      SWEEP THROUGH MATRIX TO PREPARE TO GET ROW SCALING POWERS
  190 DO 200 K=1,NA
      IF(A(K).EQ.0.0 )GO TO 200
      I=IRN(K)
      J=ICN(K)
      R(I)=R(I)+W(J,3)
  200 CONTINUE
C
C      FINAL CONVERSION TO OUTPUT VALUES.
      DO 220 I=1,N
      R(I)=R(I)/W(I,1)-W(I,5)
      C(I)=-W(I,3)
  220 CONTINUE
      GO TO 250
  230 IF(LP.GT.0)WRITE(LP,240)IFAIL
  240 FORMAT(//' ERROR RETURN',I2,' FROM MC19')
  250 RETURN
      END
C
C
C
      SUBROUTINE MA28A(N,NZ,A,LICN,IRN,LIRN,ICN,U,IKEEP,IW,W,IFLAG)
      DIMENSION A(LICN),W(N),IDISP(2),ICN(LICN),IRN(LIRN),IKEEP(N,5),
     $          IW(N,8),IPRIV2(2)
      LOGICAL GROW,LBLOCK,ABORT,ABORT1,ABORT2,ABORT3,ABORTA,ABORTB
C
C THE PARAMETERS ARE AS FOLLOWS.....
C N     INTEGER  ORDER OF MATRIX  NOT ALTERED BY SUBROUTINE.
C NZ    INTEGER  NUMBER OF NON-ZEROS IN INPUT MATRIX  NOT ALTERED
C     BY SUBROUTINE.
C A     REAL/DOUBLE PRECISION ARRAY  LENGTH LICN.  HOLDS NON-ZEROS OF
C     MATRIX ON ENTRY AND NON-ZEROS OF FACTORS ON EXIT.  REORDERED BY
C     MC20A AND MC23A AND ALTERED BY MA30A.
C LICN  INTEGER  LENGTH OF ARRAYS A AND ICN.  NOT ALTERED BY
C     SUBROUTINE.
C IRN   INTEGER ARRAY  LENGTH LIRN.  HOLDS ROW INDICES ON INPUT ...
C     USED AS WORKSPACE BY MA30A TO HOLD COLUMN ORIENTATION OF
C     MATRIX.
C LIRN  INTEGER  LENGTH OF ARRAY IRN.
C ICN   INTEGER ARRAY  LENGTH LICN.  HOLDS COLUMN INDICES ON ENTRY
C     AND COLUMN INDICES OF DECOMPOSED MATRIX ON EXIT. REORDERED BY
C     MC20A AND MC23A AND ALTERED BY MA30A.
C U     REAL/DOUBLE PRECISION VARIABLE  SET BY USER TO CONTROL
C     BIAS TOWARDS NUMERIC OR SPARSITY PIVOTING.  U=1.0 GIVES PARTIAL
C     PIVOTING WHILE U=0. DOES NOT CHECK MULTIPLIERS AT ALL.
C     VALUES OF U GREATER THAN ONE ARE TREATED AS ONE WHILE NEGATIVE
C     VALUES ARE TREATED AS ZERO.  NOT ALTERED BY SUBROUTINE.
C IKEEP  INTEGER ARRAY  LENGTH 5*N  USED AS WORKSPACE BY MA28A
C     (SEE LATER COMMENTS).  IT IS NOT REQUIRED TO BE SET ON ENTRY
C     AND, ON EXIT, IT CONTAINS INFORMATION ABOUT THE DECOMPOSITION.
C     IT SHOULD BE PRESERVED BETWEEN THIS CALL AND SUBSEQUENT CALLS
C     TO MA28B OR MA28C.
C     IKEEP(I,1),I=1,N  HOLDS THE TOTAL LENGTH OF THE PART OF ROW I
C     IN THE DIAGONAL BLOCK.
C     ROW IKEEP(I,2),I=1,N  OF THE INPUT MATRIX IS THE ITH ROW IN
C     PIVOT ORDER.
C     COLUMN IKEEP(I,3),I=1,N  OF THE INPUT MATRIX IS THE ITH COLUMN
C     IN PIVOT ORDER.
C     IKEEP(I,4),I=1,N  HOLDS THE LENGTH OF THE PART OF ROW I IN
C     THE L PART OF THE L/U DECOMPOSITION.
C     IKEEP(I,5),I=1,N  HOLDS THE LENGTH OF THE PART OF ROW I IN THE
C     OFF-DIAGONAL BLOCKS.  IF THERE IS ONLY ONE DIAGONAL BLOCK,
C     IKEEP(1,5) WILL BE SET TO -1.
C IW    INTEGER ARRAY  LENGTH 10*N.  TO OBTAIN CORRECT ALIGNMENT
C     FOR THIS ARRAY, BECAUSE PARTS OF IT ARE USED AS INTEGER*4
C     WORKSPACE, THE USER SHOULD HAVE DECLARED IT TO BE AN
C     INTEGER ARRAY OF LENGTH 5*N.  IN THE STANDARD VERSION THIS
C     DISTINCTION DISAPPEARS AND THE LENGTH OF THIS WORK-ARRAY (IN
C     THE USER'S PROGRAM) SHOULD CONSEQUENTLY BE CHANGED TO 8*N.
C W     REAL/DOUBLE PRECISION ARRAY  LENGTH N.  USED BY MC24A BOTH
C     AS WORKSPACE AND TO RETURN GROWTH ESTIMATE IN W(1).  THE USE OF
C     THIS ARRAY BY MA28A IS THUS OPTIONAL DEPENDING ON COMMON
C     BLOCK LOGICAL VARIABLE GROW.
C IFLAG  INTEGER VARIABLE  USED AS ERROR FLAG BY ROUTINE.  A POSITIVE
C     OR ZERO VALUE ON EXIT INDICATES SUCCESS.  POSSIBLE NEGATIVE
C     VALUES ARE -1 THROUGH -14.
C
C COMMON BLOCKS ... COMMON BLOCK MA28F IS USED MERELY
C     TO COMMUNICATE WITH COMMON BLOCK MA30F  SO THAT THE USER
C     NEED NOT DECLARE THIS COMMON BLOCK IN HIS MAIN PROGRAM.
C THE COMMON BLOCK VARIABLES ARE AS FOLLOWS ...
C LP,MP  INTEGER  DEFAULT VALUE 6 (LINE PRINTER).  UNIT NUMBER
C     FOR ERROR MESSAGES AND DUPLICATE ELEMENT WARNING RESP.
C NLP,MLP  INTEGER  UNIT NUMBER FOR MESSAGES FROM MA30A AND
C     MC23A RESP.  SET BY MA28A TO VALUE OF LP.
C LBLOCK  LOGICAL  DEFAULT VALUE TRUE.  IF TRUE MC23A IS USED
C     TO FIRST PERMUTE THE MATRIX TO BLOCK LOWER TRIANGULAR FORM.
C GROW    LOGICAL  DEFAULT VALUE TRUE.  IF TRUE THEN AN ESTIMATE
C     OF THE INCREASE IN SIZE OF MATRIX ELEMENTS DURING L/U
C     DECOMPOSITION IS GIVEN BY MC24A.
C EPS,RMIN,RESID  REAL/DOUBLE PRECISION VARIABLES NOT REFERENCED
C     BY MA28A.
C IRNCP,ICNCP  INTEGER  SET TO NUMBER OF COMPRESSES ON ARRAYS IRN AND
C     ICN/A RESPECTIVELY.
C MINIRN,MINICN  INTEGER  MINIMUM LENGTH OF ARRAYS IRN AND ICN/A
C     RESPECTIVELY, FOR SUCCESS ON FUTURE RUNS.
C IRANK  INTEGER   ESTIMATED RANK OF MATRIX.
C MIRNCP,MICNCP,MIRANK,MIRN,MICN INTEGER VARIABLES.  USED TO
C     COMMUNICATE BETWEEN MA30F AND MA28F VALUES OF ABOVENAMED
C     VARIABLES WITH SOMEWHAT SIMILAR NAMES.
C ABORT1,ABORT2  LOGICAL VARIABLES WITH DEFAULT VALUE TRUE.  IF FALSE
C     THEN DECOMPOSITION WILL BE PERFORMED EVEN IF THE MATRIX IS
C     STRUCTURALLY OR NUMERICALLY SINGULAR RESPECTIVELY.
C ABORTA,ABORTB  LOGICAL VARIABLES USED TO COMMUNICATE VALUES OF
C     ABORT1 AND ABORT2 TO MA30A.
C ABORT  LOGICAL  USED TO COMMUNICATE VALUE OF ABORT1 TO MC23A.
C ABORT3  LOGICAL VARIABLE NOT REFERENCED BY MA28A.
C IDISP   INTEGER ARRAY  LENGTH 2.  USED TO COMMUNICATE INFORMATION
C     ON DECOMPOSITION BETWEEN THIS CALL TO MA28A AND SUBSEQUENT
C     CALLS TO MA28B AND MA28C.  ON EXIT, IDISP(1) AND
C     IDISP(2) INDICATE POSITION IN ARRAYS A AND ICN OF THE
C     FIRST AND LAST ELEMENTS IN THE L/U DECOMPOSITION OF THE
C     DIAGONAL BLOCKS, RESPECTIVELY.
C NUMNZ  INTEGER  STRUCTURAL RANK OF MATRIX.
C NUM    INTEGER  NUMBER OF DIAGONAL BLOCKS.
C LARGE  INTEGER  SIZE OF LARGEST DIAGONAL BLOCK.
C     INTERNAL VARIABLES AND WORKSPACE USED IN  MA28A ARE DEFINED
C     WITHIN THE SUBROUTINE IMMEDIATELY PRIOR TO THEIR FIRST USE.
      COMMON /MA28E/ LP,MP,LBLOCK,GROW
      COMMON /MA28F/ EPS,RMIN,RESID,IRNCP,ICNCP,MINIRN,MINICN,
     $               IRANK,ABORT1,ABORT2
      COMMON /MA28G/ IDISP
      COMMON /MA30E/ NLP,ABORTA,ABORTB,ABORT3
      COMMON /MA30F/ MIRNCP,MICNCP,MIRANK,MIRN,MICN
C     ARRAYS  ...  SEE LATER COMMENTS ON THE SETTING OF IPRIV4.
      COMMON /MC23B/ MLP,NUMNZ,NUM,LARGE,ABORT
      EQUIVALENCE(IPRIV4,IPRIV2(1))
C SOME  INITIALIZATION AND TRANSFER OF INFORMATION BETWEEN
C     COMMON BLOCKS --- SEE EARLIER COMMENTS.
      DATA ZERO /0.0E0/
      IFLAG=0
      ABORTA=ABORT1
      ABORTB=ABORT2
      ABORT=ABORT1
      MLP=LP
      NLP=LP
C UPRIV PRIVATE COPY OF U IS USED IN CASE IT IS OUTSIDE
C     RANGE  ZERO TO ONE  AND  IS THUS ALTERED BY MA30A.
      UPRIV=U
C SIMPLE DATA CHECK ON INPUT VARIABLES AND ARRAY DIMENSIONS.
      IF (N.GT.0) GO TO 2
      IFLAG=-8
      IF (LP.NE.0) WRITE(LP,1) N
    1 FORMAT(36X,'N OUT OF RANGE = ',I10)
      GO TO 999
    2 IF (NZ.GT.0) GO TO 4
      IFLAG=-9
      IF (LP.NE.0) WRITE(LP,3) NZ
    3 FORMAT(36X,'NZ NON POSITIVE = ',I10)
      GO TO 999
    4 IF (LICN.GE.NZ) GO TO 6
      IFLAG=-10
      IF (LP.NE.0) WRITE(LP,5) LICN
    5 FORMAT(36X,'LICN TOO SMALL = ',I10)
      GO TO 999
    6 IF (LIRN.GE.NZ) GO TO 8
      IFLAG=-11
      IF (LP.NE.0) WRITE(LP,7) LIRN
    7 FORMAT(36X,'LIRN TOO SMALL = ',I10)
      GO TO 999
C
C DATA CHECK TO SEE IF ALL INDICES LIE BETWEEN 1 AND N.
    8 DO 30 I=1,NZ
      IF (IRN(I).GT.0.AND.IRN(I).LE.N.AND.ICN(I).GT.0.AND.ICN(I).LE.N)
     $   GO TO 30
      IF (IFLAG.EQ.0.AND.LP.NE.0) WRITE(LP,10)
   10 FORMAT(' ERROR RETURN FROM MA28A BECAUSE INDICES FOUND OUT OF',
     $   ' RANGE')
      IFLAG=-12
      IF (LP.NE.0) WRITE(LP,20) I,A(I),IRN(I),ICN(I)
   20 FORMAT(1X,I6,'TH ELEMENT WITH VALUE ',1PD22.14,
     $   ' IS OUT OF RANGE WITH INDICES ',I8,' ,',I8)
   30 CONTINUE
      IF (IFLAG.LT.0) GO TO 1000
C
C SORT ELEMENTS INTO ROW ORDER.
C
C THESE TWO STATEMENTS (TOGETHER WITH THE EARLIER EQUIVALENCE STATEMENT)
C SET IPRIV4 EQUAL TO THE INTEGER VALUE CONSISTING OF THE
C CONCATENATION OF THE TWO INTEGER WORDS IW(1,1) AND IW(2,1).
C THIS IS NECESSARY IN THE IBM VERSION BECAUSE MC20A EXPECTS AN
C INTEGER ARGUMENT IN IW.  THE STATEMENTS CAN BE LEFT IN
C WITHOUT AFFECTING A STANDARD FORTRAN VERSION (ASSUMING THE
C EQUIVALENCE STATEMENT IS KEPT).
      CALL MC20A(N,NZ,A,ICN,IW,IRN,0)
      IPRIV2(1)=IW(1,1)
      IPRIV2(2)=IW(1,2)
      IF (N.GT.1) IPRIV2(2)=IW(2,1)
C PART OF IKEEP IS USED HERE AS A WORK-ARRAY.  IKEEP(I,2) IS
C     THE LAST ROW TO HAVE A NON-ZERO IN COLUMN I.  IKEEP(I,3)
C     IS THE OFF-SET OF COLUMN I FROM THE START OF THE ROW.
      DO 40 I=1,N
      IKEEP(I,2)=0
   40 IKEEP(I,1)=0
C
C CHECK FOR DUPLICATE ELEMENTS .. SUMMING ANY SUCH ENTRIES AND
C     PRINTING A WARNING MESSAGE ON UNIT MP.
C MOVE IS EQUAL TO THE NUMBER OF DUPLICATE ELEMENTS FOUND.
      MOVE=0
C THE LOOP ALSO CALCULATES THE LARGEST ELEMENT IN THE MATRIX, THEMAX.
      THEMAX=ZERO
C J1 IS POSITION IN ARRAYS OF FIRST NON-ZERO IN ROW.
      J1=IPRIV4
      DO 80 I=1,N
      IF (I.NE.N) GO TO 45
      IPRIV4=NZ+1
      GO TO 49
C THESE STATEMENTS ARE USED AS ABOVE TO SET IPRIV4.
C THIS TIME THE CHANGE INDICATED BY THE SPECIAL COMMENT CARD IS
C REQUIRED FOR SUCCESSFUL OPERATION OF THE STANDARD VERSION.
   45 DO 47 L=1,2
      K=1
      J=I+1
      IF (J.LE.N) GO TO 46
      J=J-N
      K=2
   46 IPRIV2(L)=IW(J,K)
   47 CONTINUE
   49 LENGTH=IPRIV4-J1
      IF (LENGTH.EQ.0) GO TO 80
      J2=IPRIV4-1
      NEWJ1=J1-MOVE
      DO 70 JJ=J1,J2
      J=ICN(JJ)
      THEMAX=AMAX1(THEMAX,ABS(A(JJ)))
      IF (IKEEP(J,2).EQ.I) GO TO 50
C FIRST TIME COLUMN HAS OCURRED IN CURRENT ROW.
      IKEEP(J,2)=I
      IKEEP(J,3)=JJ-MOVE-NEWJ1
      IF (MOVE.EQ.0) GO TO 70
C SHIFT NECESSARY BECAUSE OF  PREVIOUS DUPLICATE ELEMENT.
      NEWPOS=JJ-MOVE
      A(NEWPOS)=A(JJ)
      ICN(NEWPOS)=ICN(JJ)
      GO TO 70
C DUPLICATE ELEMENT.
   50 MOVE=MOVE+1
      LENGTH=LENGTH-1
      JAY=IKEEP(J,3)+NEWJ1
      IF (MP.NE.0) WRITE(MP,60) I,J,A(JJ)
   60 FORMAT(' DUPLICATE ELEMENT IN POSITION ',I8,' ,',I8,
     $   ' WITH VALUE ',1PD22.14)
      A(JAY)=A(JAY)+A(JJ)
      THEMAX=AMAX1(THEMAX,ABS(A(JAY)))
   70 CONTINUE
      IKEEP(I,1)=LENGTH
      J1=IPRIV4
   80 CONTINUE
C
C KNUM IS ACTUAL NUMBER OF NON-ZEROS IN MATRIX WITH ANY MULTIPLE
C     ENTRIES COUNTED ONLY ONCE.
      KNUM=NZ-MOVE
      IF (.NOT.LBLOCK) GO TO 100
C
C PERFORM BLOCK TRIANGULARISATION.
      CALL MC23A(N,ICN,A,LICN,IKEEP,IDISP,IKEEP(1,2),IKEEP(1,3),
     $           IKEEP(1,5),IW(1,3),IW)
      IF (IDISP(1).GT.0) GO TO 130
      IFLAG=-7
      IF(IDISP(1).EQ.-1) IFLAG=-1
      IF (LP.NE.0) WRITE(LP,90)
   90 FORMAT(36X,'ERROR RETURN FROM MC23A')
      GO TO 999
C
C BLOCK TRIANGULARIZATION NOT REQUESTED.
C MOVE STRUCTURE TO END OF DATA ARRAYS IN PREPARATION FOR MA30A.
C ALSO SET LENOFF(1) TO -1 AND SET PERMUTATION ARRAYS.
  100 DO 110 I=1,KNUM
      II=KNUM-I+1
      NEWPOS=LICN-I+1
      ICN(NEWPOS)=ICN(II)
  110 A(NEWPOS)=A(II)
      IDISP(1)=1
      IDISP(2)=LICN-KNUM+1
      DO 120 I=1,N
      IKEEP(I,2)=I
  120 IKEEP(I,3)=I
      IKEEP(1,5)=-1
C
C PERFORM L/U DECOMOSITION ON DIAGONAL BLOCKS.
C TRANSFER COMMON BLOCK INFORMATION.
  130 CALL MA30A (N,ICN,A,LICN,IKEEP,IKEEP(1,4),IDISP,IKEEP(1,2),
     $            IKEEP(1,3),IRN,LIRN,IW(1,2),IW(1,3),IW(1,4),IW(1,5),
     $            IW(1,6),IW(1,7),IW(1,8),IW,UPRIV,IFLAG)
      MINIRN=MAX0(MIRN,NZ)
      MINICN=MAX0(MICN,NZ)
      IRNCP=MIRNCP
      ICNCP=MICNCP
      IRANK=MIRANK
      IF (IFLAG.GE.0) GO TO 140
      IF (LP.NE.0) WRITE(LP,135)
  135 FORMAT(36X,'ERROR RETURN FROM MA30A')
      GO TO 999
C
C REORDER OFF-DIAGONAL BLOCKS ACCORDING TO PIVOT PERMUTATION.
  140 I1=IDISP(1)-1
C
C OPTIONALLY CALCULATE ELEMENT GROWTH ESTIMATE.
      IF (I1.NE.0) CALL MC22A (N,ICN,A,I1,IKEEP(1,5),IKEEP(1,2),
     $                         IKEEP(1,3),IW,IRN)
      I1=IDISP(1)
      IEND=LICN-I1+1
C INCREMENT GROWTH ESTIMATE BY ORIGINAL MAXIMUM ELEMENT.
      IF (GROW) CALL MC24A(N,ICN,A(I1),IEND,IKEEP,IKEEP(1,4),W)
      IF (GROW) W(1)=W(1)+THEMAX
      IF (GROW.AND.N.GT.1) W(2)=THEMAX
C SET FLAG IF THE ONLY ERROR IS DUE TO DUPLICATE ELEMENTS.
      IF (IFLAG.GE.0.AND.MOVE.NE.0) IFLAG=-14
      GO TO 1000
  999 IF (LP.NE.0) WRITE(LP,998)
  998 FORMAT('+ERROR RETURN FROM MA28A BECAUSE ')
 1000 RETURN
      END
C
C
C
      SUBROUTINE MA28B (N,NZ,A,LICN,IVECT,JVECT,ICN,IKEEP,
     $                  IW,W,IFLAG)
      DIMENSION A(LICN),W(N),IDISP(2),IW(N,5)
      DIMENSION IKEEP(N,5),IVECT(NZ),JVECT(NZ),ICN(LICN)
      LOGICAL GROW,LBLOCK,ABORTA,ABORTB,ABORT1,ABORT2,ABORT3
      REAL MEPS,MRMIN
C
C THE PARAMETERS ARE AS FOLLOWS ...
C N      INTEGER  ORDER OF MATRIX  NOT ALTERED BY SUBROUTINE.
C NZ     INTEGER  NUMBER OF NON-ZEROS IN INPUT MATRIX  NOT ALTERED
C     BY SUBROUTINE.
C A      REAL/DOUBLE PRECISION ARRAY  LENGTH LICN.  HOLDS NON-ZEROS OF
C     MATRIX ON ENTRY AND NON-ZEROS OF FACTORS ON EXIT.  REORDERED BY
C     MA28D AND ALTERED BY SUBROUTINE MA30B.
C LICN   INTEGER  LENGTH OF ARRAYS A AND ICN.  NOT ALTERED BY
C     SUBROUTINE.
C IVECT,JVECT  INTEGER ARRAYS  LENGTH NZ.  HOLD ROW AND COLUMN
C     INDICES OF NON-ZEROS RESPECTIVELY.  NOT ALTERED BY SUBROUTINE.
C ICN    INTEGER ARRAY  LENGTH LICN.  SAME ARRAY AS OUTPUT FROM
C     MA28A.  UNCHANGED BY MA28B.
C IKEEP  INTEGER ARRAY  LENGTH 5*N.  SAME ARRAY AS OUTPUT FROM
C     MA28A.  UNCHANGED BY MA28B.
C IW     INTEGER ARRAY  LENGTH 4*N (5*N IN STANDARD VERSION).
C     USED AS WORKSPACE BY MA28D AND MA30B.
C W      REAL/DOUBLE PRECISION ARRAY  LENGTH N.  USED AS WORKSPACE
C     BY MA28D,MA30B AND (OPTIONALLY) MC24A.
C IFLAG  INTEGER  USED AS ERROR FLAG WITH POSITIVE OR ZERO VALUE
C     INDICATING SUCCESS.
C
C UNLESS OTHERWISE STATED COMMON BLOCK VARIABLES ARE AS IN MA28A.
C     THOSE VARIABLES REFERENCED BY MA28B ARE MENTIONED BELOW.
C LP,MP  INTEGERS  USED AS IN MA28A AS UNIT NUMBER FOR ERROR AND
C     WARNING MESSAGES, RESPECTIVELY.
C NLP    INTEGER VARIABLE USED TO GIVE VALUE OF LP TO MA30E.
C EPS    REAL/DOUBLE PRECISION  MA30B WILL OUTPUT A POSITIVE VALUE
C     FOR IFLAG IF ANY MODULUS OF THE RATIO OF PIVOT ELEMENT TO THE
C     LARGEST ELEMENT IN ITS ROW (U PART ONLY) IS LESS THAN EPS (UNLESS
C     EPS IS GREATER THAN 1.0 WHEN NO ACTION TAKES PLACE).
C RMIN   REAL/DOUBLE PRECISION  VARIABLE EQUAL TO THE VALUE OF THIS MINI
C     RATIO IN CASES WHERE EPS IS LESS THAN OR EQUAL TO 1.0
C MEPS,MRMIN  REAL/DOUBLE PRECISION VARIABLES USED BY THE SUBROUTINE
C     TO COMMUNICATE BETWEEN COMMON BLOCKS MA28F AND MA30G.
C IDISP  INTEGER ARRAY  LENGTH 2  THE SAME AS THAT USED BY MA28A.
C     IT IS UNCHANGED BY MA28B.
      COMMON /MA28E/ LP,MP,LBLOCK,GROW
      COMMON /MA28F/ EPS,RMIN,RESID,IRNCP,ICNCP,MINIRN,MINICN,
     $               IRANK,ABORT1,ABORT2
      COMMON /MA28G/ IDISP
      COMMON /MA30E/ NLP,ABORTA,ABORTB,ABORT3
      COMMON /MA30G/ MEPS,MRMIN
      IFLAG=0
      MEPS=EPS
      NLP=LP
C SIMPLE DATA CHECK ON VARIABLES.
      IF (N.GT.0) GO TO 2
      IFLAG=-11
      IF (LP.NE.0) WRITE(LP,1) N
    1 FORMAT(36X,'N OUT OF RANGE = ',I10)
      GO TO 999
    2 IF (NZ.GT.0) GO TO 4
      IFLAG=-10
      IF (LP.NE.0) WRITE(LP,3) NZ
    3 FORMAT(36X,'NZ NON POSITIVE = ',I10)
      GO TO 999
    4 IF (LICN.GE.NZ) GO TO 6
      IFLAG=-9
      IF (LP.NE.0) WRITE(LP,5) LICN
    5 FORMAT(36X,'LICN TOO SMALL = ',I10)
      GO TO 999
C
C WMAX IS LARGEST ELEMENT IN MATRIX.
    6 CALL MA28D(N,A,LICN,IVECT,JVECT,NZ,ICN,IKEEP,IKEEP(1,4),
     $   IKEEP(1,5),IKEEP(1,2),IKEEP(1,3),IW(1,3),IW,W(1),IFLAG)
      WMAX=W(1)
C IDUP EQUALS ONE IF THERE WERE DUPLICATE ELEMENTS, ZERO OTHERWISE.
      IDUP=0
      IF (IFLAG.EQ.(N+1)) IDUP=1
      IF (IFLAG.LT.0) GO TO 999
C
C PERFORM ROW-GAUSS ELIMINATION ON THE STRUCTURE RECEIVED FROM MA28D
C
C TRANSFER COMMON BLOCK INFORMATION.
      CALL MA30B(N,ICN,A,LICN,IKEEP,IKEEP(1,4),IDISP,IKEEP(1,2),
     $   IKEEP(1,3),W,IW,IFLAG)
      RMIN=MRMIN
      IF (IFLAG.GE.0) GO TO 200
      IFLAG=-2
      IF (LP.NE.0) WRITE(LP,100)
  100 FORMAT(36X,'ERROR RETURN FROM MA30B')
      GO TO 999
C
C OPTIONALLY CALCULATE THE GROWTH PARAMETER.
  200 I1=IDISP(1)
      IEND=LICN-I1+1
C INCREMENT ESTIMATE BY LARGEST ELEMENT IN INPUT MATRIX.
      IF (GROW) CALL MC24A(N,ICN,A(I1),IEND,IKEEP,IKEEP(1,4),W)
      IF (GROW) W(1)=W(1)+WMAX
C SET FLAG IF THE ONLY ERROR IS DUE TO DUPLICATE ELEMENTS.
      IF (IDUP.EQ.1.AND.IFLAG.GE.0) IFLAG=-14
      GO TO 1000
  999 IF (LP.NE.0) WRITE(LP,998)
  998 FORMAT('+ERROR RETURN FROM MA28B BECAUSE ')
 1000 RETURN
      END
C
C
C
      SUBROUTINE MA28D (N,A,LICN,IVECT,JVECT,NZ,ICN,LENR,LENRL,
     $                  LENOFF,IP,IQ,IW1,IW,W1,IFLAG)
C
C THIS SUBROUTINE NEED NEVER BE CALLED BY THE USER DIRECTLY.
C     IT SORTS THE USER'S MATRIX INTO THE STRUCTURE OF THE DECOMPOSED
C     FORM AND CHECKS FOR THE PRESENCE OF DUPLICATE ENTRIES OR
C     NON-ZEROS LYING OUTSIDE THE SPARSITY PATTERN OF THE DECOMPOSITION
C     IT ALSO CALCULATES THE LARGEST ELEMENT IN THE INPUT MATRIX.
C
      DIMENSION A(LICN),IW(N,2),IDISP(2),ICN(LICN),IVECT(NZ),JVECT(NZ),
     $          IP(N),IQ(N),LENR(N),IW1(N,3),LENRL(N),LENOFF(N)
      LOGICAL LBLOCK,GROW,BLOCKL
      COMMON /MA28E/ LP,MP,LBLOCK,GROW
      COMMON /MA28G/ IDISP
      DATA ZERO/0.0E0/
      BLOCKL=LENOFF(1).GE.0
C IW1(I,3)  IS SET TO THE BLOCK IN WHICH ROW I LIES AND THE
C     INVERSE PERMUTATIONS TO IP AND IQ ARE SET IN IW1(.,1) AND
C     IW1(.,2) RESP.
C POINTERS TO BEGINNING OF THE PART OF ROW I IN DIAGONAL AND
C   OFF-DIAGONAL BLOCKS ARE SET IN IW(I,2) AND IW(I,1) RESP.
      IBLOCK=1
      IW(1,1)=1
      IW(1,2)=IDISP(1)
      DO 10 I=1,N
      IW1(I,3)=IBLOCK
      IF (IP(I).LT.0) IBLOCK=IBLOCK+1
      II=IABS(IP(I)+0)
      IW1(II,1)=I
      JJ=IQ(I)
      JJ=IABS(JJ)
      IW1(JJ,2)=I
      IF (I.EQ.1) GO TO 10
      IF(BLOCKL) IW(I,1)=IW(I-1,1)+LENOFF(I-1)
      IW(I,2)=IW(I-1,2)+LENR(I-1)
   10 CONTINUE
C PLACE EACH NON-ZERO IN TURN INTO ITS CORRECT LOCATION
C    IN THE A/ICN ARRAY.
      IDISP2=IDISP(2)
      DO 300 I=1,NZ
C NECESSARY TO AVOID REFERENCE TO UNASSIGNED ELEMENT OF ICN.
      IF(I.GT.IDISP2) GO TO 30
      IF (ICN(I).LT.0) GO TO 300
   30 IOLD=IVECT(I)
      JOLD=JVECT(I)
      AA=A(I)
C THIS IS A DUMMY LOOP FOR FOLLOWING A CHAIN OF INTERCHANGES.
C   IT WILL BE EXECUTED NZ TIMES IN TOTAL.
      DO 200 IDUMMY=1,NZ
C PERFORM SOME VALIDITY CHECKS ON IOLD AND JOLD.
      IF (IOLD.LE.N .AND. IOLD.GT.0
     $      .AND. JOLD.LE.N .AND. JOLD.GT.0) GO TO 60
      IF (LP.NE.0) WRITE(LP,40) I,A(I),IOLD,JOLD
   40 FORMAT(' ELEMENT ',I6,' WITH VALUE ',1PD22.14,
     $   ' HAS INDICES ',I8,' ,',I8,/36X,'INDICES OUT OF RANGE')
      IFLAG=-12
      GO TO 340
   60 INEW=IW1(IOLD,1)
      JNEW=IW1(JOLD,2)
C ARE WE IN A VALID BLOCK AND IS IT DIAGONAL OR OFF-DIAGONAL?
      IF (IW1(INEW,3)-IW1(JNEW,3)) 70,100,90
   70 IFLAG=-13
      IF (LP.NE.0) WRITE(LP,80) IOLD,JOLD
   80 FORMAT(36X,'NON-ZERO',I7,' ,',I6,' IN ZERO OFF-DIAGONAL BLOCK')
      GO TO 340
   90 J1=IW(INEW,1)
      J2=J1+LENOFF(INEW)-1
      GO TO 160
C ELEMENT IS IN DIAGONAL BLOCK.
  100 J1=IW(INEW,2)
      IF (INEW.GT.JNEW) GO TO 110
      J2=J1+LENR(INEW)-1
      J1=J1+LENRL(INEW)
      GO TO 160
  110 J2=J1+LENRL(INEW)
C BINARY SEARCH OF ORDERED LIST  .. ELEMENT IN L PART OF ROW.
      DO 140 JDUMMY=1,N
      MIDPT=(J1+J2)/2
      JCOMP=IABS(ICN(MIDPT)+0)
      IF (JNEW-JCOMP) 120,180,130
  120 J2=MIDPT
      GO TO 140
  130 J1=MIDPT
  140 CONTINUE
      IFLAG=-13
      IF (LP.NE.0) WRITE(LP,150) IOLD,JOLD
  150 FORMAT(36X,' ELEMENT ',I6,' ,',I6,' WAS NOT IN L/U PATTERN')
      GO TO 340
C LINEAR SEARCH ... ELEMENT IN L PART OF ROW OR OFF-DIAGONAL BLOCKS.
  160 DO 170 MIDPT=J1,J2
      IF (IABS(ICN(MIDPT)+0).EQ.JNEW) GO TO 180
  170 CONTINUE
      IFLAG=-13
      IF (LP.NE.0) WRITE(LP,150) IOLD,JOLD
      GO TO 340
C EQUIVALENT ELEMENT OF ICN IS IN POSITION MIDPT.
  180 IF (ICN(MIDPT).LT.0) GO TO 250
      IF (MIDPT.GT.NZ.OR.MIDPT.LE.I) GO TO 220
      W1=A(MIDPT)
      A(MIDPT)=AA
      AA=W1
      IOLD=IVECT(MIDPT)
      JOLD=JVECT(MIDPT)
      ICN(MIDPT)=-ICN(MIDPT)
  200 CONTINUE
  220 A(MIDPT)=AA
      ICN(MIDPT)=-ICN(MIDPT)
      GO TO 300
  250 A(MIDPT)=A(MIDPT)+AA
C SET FLAG FOR DUPLICATE ELEMENTS.
      IFLAG=N+1
  300 CONTINUE
C RESET ICN ARRAY  AND ZERO ELEMENTS IN L/U BUT NOT IN A.
C ALSO CALCULATE MAXIMUM ELEMENT OF A.
  340 W1=ZERO
      DO 400 I=1,IDISP2
      IF (ICN(I).LT.0) GO TO 350
      A(I)=ZERO
      GO TO 400
  350 ICN(I)=-ICN(I)
      W1=AMAX1(W1,ABS(A(I)))
  400 CONTINUE
      RETURN
      END
C
C
C
      SUBROUTINE MA28C(N,A,LICN,ICN,IKEEP,RHS,W,MTYPE)
      DIMENSION A(LICN),RHS(N),W(N),IDISP(2),ICN(LICN),IKEEP(N,5)
      LOGICAL ABORT1,ABORT2
      REAL MRESID
C
C THE PARAMETERS ARE AS FOLLOWS ....
C N     INTEGER  ORDER OF MATRIX  NOT ALTERED BY SUBROUTINE.
C A      REAL/DOUBLE PRECISION ARRAY  LENGTH LICN.  THE SAME ARRAY AS
C     WAS USED IN THE MOST RECENT CALL TO MA28A OR MA28B.
C LICN  INTEGER  LENGTH OF ARRAYS A AND ICN.  NOT ALTERED BY
C     SUBROUTINE.
C ICN    INTEGER ARRAY  LENGTH LICN.  SAME ARRAY AS OUTPUT FROM
C     MA28A.  UNCHANGED BY MA28C.
C IKEEP  INTEGER ARRAY  LENGTH 5*N.  SAME ARRAY AS OUTPUT FROM
C     MA28A.  UNCHANGED BY MA28C.
C RHS    REAL/DOUBLE PRECISION ARRAY  LENGTH N.  ON ENTRY, IT HOLDS THE
C     RIGHT HAND SIDE.  ON EXIT, THE SOLUTION VECTOR.
C W      REAL/DOUBLE PRECISION ARRAY  LENGTH N. USED AS WORKSPACE BY
C     MA30C.
C MTYPE  INTEGER  USED TO TELL MA30C TO SOLVE THE DIRECT EQUATION
C     (MTYPE=1) OR ITS TRANSPOSE (MTYPE.NE.1).
C
C UNLESS OTHERWISE STATED COMMON BLOCK VARIABLES ARE AS IN MA28A.
C     THOSE VARIABLES REFERENCED BY MA28C ARE MENTIONED BELOW.
C RESID  REAL/DOUBLE PRECISION  VARIABLE RETURNS MAXIMUM RESIDUAL OF
C     EQUATIONS WHERE PIVOT WAS ZERO.
C MRESID  REAL/DOUBLE PRECISION VARIABLE USED BY MA28C TO
C     COMMUNICATE BETWEEN MA28F AND MA30H.
C IDISP  INTEGER ARRAY  LENGTH 2  THE SAME AS THAT USED BY MA28A.
C     IT IS UNCHANGED BY MA28B.
      COMMON /MA28F/ EPS,RMIN,RESID,IRNCP,ICNCP,MINIRN,MINICN,
     $               IRANK,ABORT1,ABORT2
      COMMON /MA28G/ IDISP
C
C THIS SUBROUTINE PERFORMS THE SOLUTION OF THE SET OF EQUATIONS.
      COMMON /MA30H/ MRESID
C
C TRANSFER COMMON BLOCK INFORMATION.
      CALL MA30C (N,ICN,A,LICN,IKEEP,IKEEP(1,4),IKEEP(1,5),IDISP,
     $            IKEEP(1,2),IKEEP(1,3),RHS,W,MTYPE)
      RESID=MRESID
      RETURN
      END
C            
C Procedura contenete la variabile per l'identificazione della versione
C        
      SUBROUTINE SCCS_ma28
      CHARACTER*80 SccsID
      DATA SccsId/'@(#)ma28.f	2.1\t7/10/95'/
      END
