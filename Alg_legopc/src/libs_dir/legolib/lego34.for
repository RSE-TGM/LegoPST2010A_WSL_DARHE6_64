C******************************************************************************
C modulo lego34.pf
C tipo 
C release 2.1
C data 7/10/95
C reserver @(#)lego34.pf	2.1
C******************************************************************************
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                      C
C           LEGO unificato per singola / doppia precisione             C
C                 e per diverse piattaforme operative                  C
C                                                                      C
C   Attivata versione singola precisione per sistema operativo Unix    C
C                                                                      C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      SUBROUTINE  LEGO34
C
C      PROGRAMMA  L E G O 3 4
C
C      INCLUDE 'LG3_PARAMETER.F'
C**   Descrizione delle parameter di LG3
C**
C**   N000= MOLTIPLICATORE
C**
C**   N001= N. MODULI
C**   N002= N. BLOCCHI
C**   N003= N.STATI+ALG. = ORDINE MASSIMO SISTEMA ALGEBRICO
C**   N004= N. INGRESSI
C**   N005= N. VARIABILI
C**   N006= N. VAR. DI 1 BLOCCO (moduli di processo)
C**   NT006= N. VAR. DI 1 BLOCCO (moduli di regolazione)
C**   N007= N. DI DATI
C**   N008= N. DI EQUAZIONI DI UN BLOCCO
C**   NR00= N. DI TERMINI #0 PER OGNI EQUAZIONE
C**   NP00= N. DI PERTURBAZIONI
C
      PARAMETER (N000=160, N001=N000*10, N002=N000*25, N003=N000*50,
     $           N004=N000*25, N005=N000*100, N006=100, NT006=N003+N004,
     $           N007=N000*500, N008=40, NR00=12, NR01=70, NR02=18, 
     $           NP00=10)
C
C**   M001= N. TOTALE INGRESSI =N005-N003
C**   M002= N. INGRESSI = USCITE  =M001-N004
C
      PARAMETER (M001=N005-N003, M002=M001-N004, M003=N002+1,
     $           M004=N003+1, M005=N004+1, M009=N005+1)
C
C         M006=N.TERMINI # 0 DELLO JACOBIANO DEL SISTEMA
C         M007=N.TERMINI # 0 DELLO JACOBIANO FATTORIZZATO (MA28)
C         NZP0=N.TERMINI # 0 DELLO JAC.FATT. P (GRAM SCHMIDT)
C         NZG0=N.TERMINI # 0 DELLO JAC.FATT. G (GRAM SCHMIDT)
C
      PARAMETER (M006=N003*NR00, M007=2*M006, M008=8*N003)
      PARAMETER (NZP0=N003*NR01,NZG0=N003*NR02)

C
      DIMENSION NOSL(N001),NOSUB(N002),NOBLC(N002,2),
     $          NUSTA(N002),NUSCI(N002),NINGR(N002),ISLB(N002),
     $          IP(M003),IPVRS(N005),
     $          IPS(M009),IPVRT(N005),IPI(M009),IPVRI(M001)
      DIMENSION XY(N005),UU(N005),XYU(N005),DATI(N007),IPDATI(M003),
     $          CNXYU(N005),TOLO(N003),RN(N003),RNO(N003),TOLL(N003),
     $          XYO(N005),TN(N005),RIGA(N003),AJAC(N008,N006),RNI(N003),
     $          ICONV(N003),FJ(M007),IRJ(M007),ICJ(M007),IKMA28(M008),
     $          IWMA28(M008),WMA28(N003),XBL(NT006,3),PESI(N005)
      CHARACTER*8 VARI(N005),VAR(N005),SIVAR(N005),VARBL(NT006,3)
C
      CHARACTER*100  NMSIVA(N003)
      CHARACTER*100  NMVARI(N004)
      CHARACTER*80   NMBLOC(N002)
      DIMENSION IOUSIV(N003),IOUVAR(N004)
      DIMENSION SYTVAR(NT006,2)

C   parametri per stampe
C stampa1 = 1 stampa tempi e informazioni (file stampe), = 0 non stampa 
C stampa2 = 1 stampa tempi finali (file stampe), = 0 non stampa     
C      
      PARAMETER(stampa1=0,stampa2=0)     
      
      CHARACTER*1 CHABS
      CHARACTER*4 CHPCEN
      INTEGER IPN(M004),IPNA(M004),IPNB(M004),IPNP(M009),IPNG(M004)
      INTEGER IPNR(N003),INDP(NZP0),INDG(NZG0),IEQ(M004)	
      REAL*8 FJD(M006),PD(NZP0),GD(NZG0)
      REAL*8 D1(N003),D2(N005),D3(N005),WD(N005)  
            
C
C______ FILES DI LAVORO DI LG3
C
      CHARACTER*32 F14DAT,F03DAT,F04DAT,F24DAT,LG3ERR
C
      COMMON/LG3FLS/ F14DAT,F03DAT,F04DAT,F24DAT,LG3ERR
C
      CHARACTER*2 IACC, SI, SIP
C
      COMMON/NORM/P0,H0,T0,Q0,R0,AL0,V0,DP0
      COMMON/DIMAJA/NRXJC,NCXJC
      COMMON/REGIME/KREGIM
      LOGICAL KREGIM

C
      COMMON/SSTCH/KSW(6)
      COMMON/BLOSE/NBLSE
C_____ NBLSE = NUMERO DI BLOCCHI (I PRIMI) CHE NON HANNO EQUAZIONI
C
C******************* TAVOLE *****************************************
C       ILEGO = INDICATORE DEL PROGRAMMA CHIAMANTE LE TAVOLE
C             =1 LEGO E` IL PROGRAMMA CHIAMANTE
C             =0 NON E` IL LEGO IL PROGRAMMA CHIAMANTE
C
C       ICNTMX = CONTATORE STABILITO DAL PROGRAMMA CHIAMANTE LE TAVOLE
C                  SUPERATO IL QUALE VIENE DECRETATO LO STOP .
C
      COMMON/LGTV01/LGTEMP,ILEGO,ICOUNT,ICNTMX
      COMMON/LGTV02/LGMODU,LGBLOC
      CHARACTER*8 LGMODU,LGBLOC
      REAL LGTEMP
      CHARACTER*8 VAVA
C
      DATA SI/'SI'/,SIP/'si'/
      DATA IBLK/' '/,NOT/'NO'/,BLK/' '/,ISSO/'SI'/,ISTAR/'****'/,
     $     STAR/'****'/
      DATA PZERO/20000000./,HZERO/1000000. /,QZERO/1000./
      DATA TZERO/1000./,ROZERO/100./
      DATA LG/'LG'/,IS/'SI'/
C
C  Setta il contatore errori tavole ad un valore che provoca uscita
C  immediata
C
      ILEGO    = 1
      LGTEMP  = 0.
C******************* TAVOLE *****************************************
      NX1=N001
      NX2=N002
      NX3=N003
      NX4=N004
      NX5=N005
      NX6=NT006
      NX8=N008
      NRXJC=NX8
      NCXJC=N006
      MX1=M001
      MX2=M002
      NZMAX=M006
      MXCOL=M007
      MXROW=M007
      NZPMX=NZP0
      NZGMX=NZG0
C
      NITERJ=5
      NJACMX=10
      KREGIM=.TRUE.
C
C     PROGRAMMA CHE CALCOLA IL REGIME DELL'IMPIANTO
C
      WRITE(6,1000)
 1000 FORMAT(1H1//10X,'PROGRAMMA LEGO - CALCOLO DEL REGIME INIZIALE'//)

      KS=9
      CALL SSWTCH(KS,LL)
      IF(KS.EQ.9)GO TO 798
      CALL PSWTCH(4)
      CALL SSWTCH(KS,LL)
  798 CONTINUE

C
C_______________ ASSEGNAZIONE DELLA TOLLERANZA PER IL CALCOLO.
C

      WRITE(6,5552)
 5552 FORMAT(10X,'FORNISCI LA TOLLERANZA PER IL CALCOLO')
      READ(5,*)TOLLER

      FATOLL=TOLLER
  800 IF(FATOLL.LT.1.E-6)FATOLL=1.E-6
 6721 FORMAT(F10.0)
 6722 FORMAT(//10X,'TOLLERANZA PER IL CALCOLO = ',E12.5//)
      WRITE(6,6722)FATOLL
C
C     LETTURA DATI DA FILE 04 DI LEGO3
C
      REWIND 4
      READ(4)NBL,NEQAL,NBL1,NVART,NEQSIS,NEQS1,NPVRT,NU,NU1,NVRI
      READ(4)ISSIS,NBTRI,NST,SIGLA,(NOSL(I),I=1,NST)
      READ(4)(NOSUB(I),NOBLC(I,1),NOBLC(I,2),NUSTA(I),NUSCI(I),
     $       NINGR(I),ISLB(I),NMBLOC(I),I=1,NBL)
      READ(4)(IP(I),I=1,NBL1),(VAR(I),IPVRS(I),I=1,NVART)
      READ(4)
      READ(4)
      READ(4)P0,H0,T0,Q0,R0,AL0,V0,DP0
      READ(4)(PS,I=1,NEQSIS),(PS,I=1,NU),(XYU(I),I=1,NVART)
      READ(4)NDATI,(IPDATI(I),I=1,NBL1),(DATI(I),I=1,NDATI),
     $             (CNXYU(I),I=1,NVART),(TOLO(I),I=1,NEQSIS)
      READ(4)IREGIM
      IF(IREGIM.NE.0)GO TO 10
      WRITE(6,3300)SIGLA
 3300 FORMAT(//10X,'IL REGIME DELL'' IMPIANTO ',A8,
     $   '  E'' GIA'' STATO CALCOLATO')
      RETURN
C
C      STAMPA DELLE CONDIZIONI INIZIALI PER IL CALCOLO
C
   10 WRITE(6,5050)SIGLA
 5050 FORMAT(//10X,'IMPIANTO ',A8//10X)
      WRITE(6,8081)
 8081 FORMAT(///10X,'CONDIZIONI INIZIALI ASSEGNATE'
     $/10X,'PER IL CALCOLO DEL REGIME'///)
      DO40 I=1,NVART
      FJ(I)=XYU(I)*CNXYU(I)
   40 CONTINUE
      CALL STA2(NBL,NOBLC,NOSUB,NUSTA,NUSCI,NINGR,
     $          IP,VAR,NX2,NX5,FJ,NX6,VARBL,XBL)
C
C      INIZIO DELLA PROCEDURA DI CALCOLO
C
      READ(4) NOTO,(VARI(I),UU(I),I=1,NOTO),
     $        NNOTO,(SIVAR(I),XY(I),PESI(I),I=1,NNOTO)
      WRITE(6,3000)
 3000 FORMAT(//10X,'VARIABILI NOTE AL PROBLEMA'//)
      WRITE(6,3001)(VARI(I),I=1,NOTO)
 3001 FORMAT(10(1X,A8))
C
C      DEFINIZIONE DELLE MATRICI DI COLLEGAMENTO/
C
      DO 140 J=1,NVART
      VAVA=VAR(J)
      DO 135 K=1,NNOTO
      IF(VAVA.EQ.SIVAR(K))GO TO 136
  135 CONTINUE
      DO 145 K=1,NOTO
      IF(VAVA.EQ.VARI(K))GO TO 146
  145 CONTINUE
      IER=1
      WRITE(6,3313)VAVA
 3313 FORMAT(//10X,'ER- SUB. LEGO 2. ERRORE DURANTE DEF.PUNT.',
     $   'INGR.BLOCC.'/10X,'VAR = ',A8 /)
      GO TO 140
  136 IPVRS(J)=K
      GO TO 140
  146 IPVRS(J)=-K
  140 CONTINUE
  150 CONTINUE
      IF(IER.EQ.1)RETURN
C
C     DEFINIZIONE DEL PUNTATORE DELLE VARIABILI DEL SISTEMA (SIVAR)
C     VERSO LE VARIABILI DI OGNI BLOCCO
C
      N=0
      IPS(1)=0
      DO 200 I=1,NNOTO 
      VAVA=SIVAR(I)
      DO 180 J=1,NVART
      IF(VAVA.NE.VAR(J))GO TO 180
      N=N+1
      IPVRT(N)=J
  180 CONTINUE
      IPS(I)=IPS(I)+1
      IPS(I+1)=N
  200 CONTINUE
      IPS(NNOTO+1)=N+1
C
C     DEFINIZIONE DEL PUNTATORE DEGLI INGRESSI DEL SISTEMA VERSO
C     IL VETTORE VAR (VARIABILI DI OGNI BLOCCO)
C
      N=0
      IPI(1)=0
      DO 220 I=1,NOTO
      VAVA=VARI(I)
      DO 210 J=1,NVART
      IF(VAVA.NE.VAR(J))GO TO 210
      N=N+1
      IPVRI(N)=J
  210 CONTINUE
      IPI(I)=IPI(I)+1
      IPI(I+1)=N
  220 CONTINUE
      IPI(NOTO+1)=N+1
C
C     STAMPE OPZIONALI
C
      CALL SSWTCH(4,LL)
      IF(LL.NE.1)GO TO 231
      WRITE(6,2000)
 2000 FORMAT(1H1//10X,'STAMPE DA SSWTCH 4   '//)
      DO 230 I=1,NBL
      WRITE(6,2001) NOSUB(I),NOBLC(I,1),NOBLC(I,2),NUSTA(I),NUSCI(I),
     $              NINGR(I),ISLB(I),IP(I)
 2001 FORMAT(10X,A4,2X,2A4,5I6)
  230 CONTINUE
      WRITE(6,2002)IP(NBL+1)
 2002 FORMAT(48X,I6)
C
      WRITE(6,2003) (I,VAR(I),IPVRS(I),I=1,NVART)
 2003 FORMAT(10X,I6,2X,A8,I6)
      DO 240 J=1,NNOTO
      I1=IPS(J)
      I2=IPS(J+1)-1
      WRITE(6,2005) J,(IPVRT(I),I=I1,I2)
 2005 FORMAT(10X,I5,5X,20I3)
  240 CONTINUE
C
      DO 241 J=1,NOTO
      I1=IPI(J)
      I2=IPI(J+1)-1
      WRITE(6,2005) J,(IPVRI(I),I=I1,I2)
  241 CONTINUE
C
  231 CALL SSWTCH(1,LL)
      IF(LL.NE.1) GO TO 300
      WRITE(6,3002)
 3002 FORMAT(//10X,'ORDINE DELLE EQUAZIONI'//)
      I2=0
      DO 235 I=1,NBL
      NY=NUSTA(I)+NUSCI(I)
      I1=I2+1
      I2=I1+NY-1
      K1=IP(I)
      K2=K1+NY-1
      WRITE(6,3003) NOBLC(I,1),NOBLC(I,2),NOSUB(I),
     $              NUSTA(I),NUSCI(I),(K,VAR(K1+K-I1),K=I1,I2)
 3003 FORMAT(2X,2A4,' (',A4,') ',2I3,6X,6(2X,I5,1X,A8)/
     $       (30X,6(2X,I5,1X,A8)))
  235 CONTINUE
C
      WRITE(6,3004)
 3004 FORMAT(//10X,'ORDINE DELLE INCOGNITE'//)
      WRITE(6,3005) (K,SIVAR(K),K=1,NNOTO)
 3005 FORMAT(8(2X,I5,1X,A8))
C
C
  300 CONTINUE
      TEMPO=0.
      DO 301 I=1,NEQSIS
      TOLL(I)=FATOLL
  301 CONTINUE
C
C
C      RISOLUZIONE DEL SISTEMA ALGEBRICO DI REGIME
C
      WRITE(6,302) 
  302 FORMAT(//10X,'RISOLVERE CON MA28 O GRAM SCHMIDT [M/S]?')
      READ(5,'(A1)') CHABS      
  303 WRITE(6,304)
      READ(5,'(I1)') NUMS
      IF (NUMS.LT.0.OR.NUMS.GT.2) GOTO 303
  304 FORMAT(//10X,'0 = SENZA SMORZAMENTO',
     $        /10X,'1 = SMORZAMENTO SULLE ECCEDENZE',
     $        /10X,'2 = SMORZAMENTO SU TUTTE LE VARIABILI')
      IF(NUMS.EQ.1.OR.NUMS.EQ.2)THEN
         WRITE(6,*)'         PERCENTUALE SMORZAMENTO'
         READ(5,'(A)') CHPCEN
         READ(CHPCEN,'(F)')PCEN
         IF(PCEN.LE.0.)PCEN=0.1
      ENDIF          
      IF (CHABS.EQ.'M'.OR.CHABS.EQ.'m') THEN
          WRITE(6,*) '*********** RISOLUZIONE CON MA28'
          CALL  LEGREG(NOTO,NNOTO,IGO,NEQSIS, NBL,ISLB,
     $     NUSTA,NUSCI,IPDATI,DATI,IP,TN,CDT,XYU,RN,ICONV,
     $     SIVAR,NX3,IPVRS,TOLL,RNO,XYO,JACYES,NITERJ,NJACMX,IPS,IPVRT,

     $     XY,UU,NU,IPI,IPVRI,FJ,RIGA, NEQAL,TEMPO,AJAC,NX8,NOBLC,
     $     NX2,RNI,IRJ,ICJ,IKMA28,IWMA28,WMA28,NZMAX,MXCOL,MXROW,NOSUB,
     $     NUMS,PCEN,stampa1,stampa2)
      ELSE
          WRITE(6,*) '***** RISOLUZIONE CON METODO GRAM SCHMIDT PESATO'
          CALL WGSREG(NOTO,NNOTO,IGO,NEQSIS, NBL,ISLB,
     $      NUSTA,NUSCI,IPDATI,DATI,IP,TN,CDT,XYU,RN,ICONV,
     $      SIVAR,NX3,IPVRS,TOLL,RNO,XYO,JACYES,NITERJ,NJACMX,IPS,IPVRT,

     $      XY,UU,NU,IPI,IPVRI,FJ,RIGA, NEQAL,TEMPO,AJAC,NX8,NOBLC,
     $      NX2,RNI,IRJ,ICJ,NZMAX,MXCOL,MXROW,NOSUB,PESI,
     $      NZPMX,NZGMX,IPN,IPNA,IPNB,IPNP,IPNG,IPNR,INDP,INDG,IEQ,	
     $      FJD,PD,GD,D1,D2,D3,WD,NUMS,PCEN,stampa1,stampa2)
      ENDIF
C
C      STAMPE RISULTATI
C
      IF(IGO.NE.1) THEN
      WRITE(6,8560)
 8560 FORMAT(///10X,'IL REGIME INIZIALE NON SODDISFA LA PRECISIONE'
     $/10X,'DI CALCOLO IMPOSTA .')

      WRITE(6,*)'  SE VUOI COMUNQUE ACCETTARLO, RISPONDI SI '
      READ(5,'(A)')IACC
      IF((IACC.NE.SI).AND.(IACC.NE.SIP)) RETURN

      WRITE(6,8561)
 8561 FORMAT(///10X,'IL REGIME VIENE COMUNQUE ACCETTATO' )
      ENDIF
      WRITE(6,5055)
 5055 FORMAT(//10X,'CONDIZIONI DI REGIME CALCOLATE'//)
C
C      REGISTRAZIONE DEL FILE 04 CON I RISULTATI OTTENUTI
C
C      VIENE RILETTA LA TOPOLOGIA DEL MODELLO DINAMICO (IP, IPVRS)
C
      REWIND  4
      READ(4)
      READ(4)
      READ(4)
      READ(4)(IP(I),I=1,NBL1),(VAR(I),IPVRS(I),I=1,NVART)
C
      READ(4)(NPS,I=1,NEQS1),(SIVAR(I),NMSIVA(I),
     $        IOUSIV(I),I=1,NEQSIS)
      READ(4)(NPS,I=1,NU1),(VARI(I),NMVARI(I),
     $        IOUVAR(I),I=1,NU)
C
      READ(4)
C
C______ SE NEL MODELLO ESISTONO BLOCCHI SENZA EQUAZIONI (REGOLATORI)
C       VENGONO RICHIAMATI AFFINCHE` CALCOLINO LE CONDIZIONI INIZIALI
C       DELLE LORO VARIABILI INTERNE
C
      IF(NBLSE.GT.0) THEN
C
      CALL INIZBL(ISLB,IPDATI,DATI,IP,XYU,IPVRS,NOBLC,NX2,
     $               NUSTA,NUSCI,NVART)
      ENDIF
C
      DO 400 I=1,NVART
      J=IPVRS(I)
      IF(J.LT.0)GO TO 399
      XY(J)=XYU(I)
      XYO(J)=XY(J)*CNXYU(I)
      GO TO 400
  399 J=-J
      UU(J)=XYU(I)
      TN(J)=UU(J)*CNXYU(I)
  400 CONTINUE
      WRITE(4)(XY(I),I=1,NEQSIS),(UU(I),I=1,NU),(XYU(I),I=1,NVART)
      IREGIM=0
      WRITE(4)NDATI,(IPDATI(I),I=1,NBL1),(DATI(I),I=1,NDATI),
     $              (CNXYU(I),I=1,NVART),(TOLO(I),I=1,NEQSIS)
C
      WRITE(4)IREGIM
C
C  REGISTRAZIONE SU FILE 24 DEL REGIME CALCOLATO
C
      OPEN(UNIT=24,FILE=F24DAT,STATUS='UNKNOWN',FORM='FORMATTED')
      CALL REC24(NEQSIS,XYO,NU,TN)
C
      DO 420 I=1,NVART
      FJ(I)=XYU(I)*CNXYU(I)
  420 CONTINUE
      CALL STA2(NBL,NOBLC,NOSUB,NUSTA,NUSCI,NINGR,
     $          IP,VAR,NX2,NX5,FJ,NX6,VARBL,XBL)
      WRITE(6,4521)
 4521 FORMAT(//10X,'IL PROGRAMMA DA RICHIAMARE PER CONTINUARE LO STUDIO'
     $/10X,'E''  -LEGO4-')
C
      RETURN
      END
C            
C Procedura contenete la variabile per l'identificazione della versione
C        
      SUBROUTINE SCCS_lego34
      CHARACTER*80 SccsID
      DATA SccsId/'@(#)lego34.pf	2.1\t7/10/95'/
      END
