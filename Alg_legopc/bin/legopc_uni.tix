
package require Tix

source $env(LG_TIX)/checkopen.tcl

proc aprimodello { c c2 f4 modo } {
    global showon curFileName DIRMODEL

    if {[ apri_modello $c $c2 $modo]} { return 1};
#tk_messageBox -icon error -message "aprimodello: $curFileName appname=[tk appname] "

    ShowNamesfilt $c $c2 $showon;
    if { $::LINUXNOMATLAB != 1 } {
        open_simul $f4 $DIRMODEL/tasks.dat;
##        load_task $DIRMODEL $c4
    }
}

proc  ImportF01 {c} {
    global curFileName  modified  needbuild f14File DIRMODEL

	set model_name [lindex [file split [file dirname $curFileName]] end]
	if {$model_name == "."} {
		set model_name "untitled"
	}
	set mex [tk_messageBox -icon question -type yesno \
         -title Question -parent . -message "Do you want to import \
          a f01.dat ?"]
	if {$mex == "yes"} {
		$c delete all
		wm title . "LegoPC - untitled"
            .menu.file entryconfigure 4 -state disabled
            set curFileName untitled; set modified 0; set needbuild 0
	    set typesRead {
	            {"f01.dat files"	{.dat}		TEXT}

	            {"All files"		*}
            }

        set filef01 "f01.dat"
	set filef01 [tk_getOpenFile -filetypes $typesRead -parent $c \
	    -initialfile $filef01 -defaultextension .dat -title "Open f01 to import"]


		catch { destroy  $c.mod }
		toplevel $c.mod
		wm title $c.mod "New model"
  grab $c.mod
		wm positionfrom $c.mod user
		label $c.mod.lab -text "Model name:" -font "Courier 12"
		entry $c.mod.ent -textvariable modelName
		frame $c.mod.but
		button $c.mod.but.ok -text OK -command {
                   if [file isdirectory $env(LG_MODELS)/$modelName] {
                      tk_messageBox -icon info -message "model already exists!" \
                                    -type ok -parent .
			 } elseif {[string length $modelName] > 8} {
                     tk_messageBox -icon warning -message "Model name too long (max 8 char.)" \
                                    -type ok -parent .

                   } else {
			    file mkdir $env(LG_MODELS)/$modelName
			    set curFileName $env(LG_MODELS)/${modelName}/${modelName}.tom
                            set ::nometom $modelName.tom
			set DIRMODEL [ file dirname $curFileName ]
			set f14File $DIRMODEL/f14.dat
                        cd $DIRMODEL

		      destroy $c.mod
		      set ::donef01 1
		          if {[writeFiles $c $curFileName $envir]} { return 1}
#tk_messageBox -icon error -message "topWrite: $DIRMODEL $f14File $curFileName"
                   }
		}
		button $c.mod.but.canc -text Canc -command {
			destroy $c.mod
			return 1
		}
		pack $c.mod.but.ok $c.mod.but.canc -side left -padx 2m -fill x
		pack $c.mod.lab $c.mod.ent $c.mod.but -side top -pady 3m -padx 2m

	   vwait ::donef01
	   file copy $filef01 f01totom.dat
	   set dirf01 [file dirname "$filef01"]
	   file copy $dirf01/f14.dat f14.dat
	set comm1 [info nameofexecutable]
	set comm2 "$::env(LG_TIX)/f01totom.tcl"

	exec $comm1 -f $comm2 $::nometom &

#	set curdir [file dirname "$filef01"]
#	cd $curdir

	} else {
            return 1
        }

	return 0

}


#button $fsl.config_steady  -text "Steady state options" -state normal -command 

##after 1000 CIAO
#
#proc CIAO {} {
#	tk_messageBox -message "ciao"
#	update
#	after 4000 CIAO
#}

set ::LINUXPLAT 0
set ::LINUXNOMATLAB 0
if  { $::tcl_platform(os) == "Linux" } {
set ::convConst 76
set ::LINUXPLAT 1
set ::LINUXNOMATLAB 1
set ::styledrag 1
} else { 
set ::convConst 72 
package require registry 1.0
set ::styledrag 0
}

#determinazione del fattore di scala corrente
set  ::fattsca [ tk scaling ]
####tk scaling 1
#determinazione della risoluzione del monitor
set  ::dpimon [winfo fpixels . 1i ]
#tk_messageBox -message "$::tcl_platform(os) scale=$::fattsca dpimon=$::dpimon convConst=$::convConst"  -type ok





proc MainTextFont {w wtext args} {
    global demo

#
#    if {![info exists demo(welmsg)]} {
#	return
#    }

    set font  [$demo(welfont) cget -value]
    set point [$demo(welsize) cget -value]
# debug tk_messageBox  -message "MainTextFont: font=$font point=$point"    
if { $font != "" } { 
	set demo(welfont_index) [$demo(welfont) subwidget listbox curselection  ]  
#tk_messageBox -icon warning -message "MainTextFont: --> $demo(welfont_index)" -type ok
}
if { $point != "" } { 
	set demo(welsize_index) [$demo(welsize) subwidget listbox curselection  ]  
#tk_messageBox -icon warning -message "MainTextFont: --> $demo(welsize_index)" -type ok
}

#    case $font {
#	"Courier" {
#	    set f courier
#	}
#	"Helvetica" {
#	    set f helvetica
#	}
#	"Lucida" {
#	    set f lucida
#	}
#	default {
#	    set f times
#	}
#    }
#

    set ::xfont [list $font $point]
##$wtext configure  -font $font -fg $::retcolor

if {$font != ""} {$wtext configure  -font [lindex $::xfont 0]} 

#    if [catch {$demo(welmsg) config -font $xfont} err] {
#	puts \a$err
#    }

}


proc switchuser {} {

	global env
	
	set curdirectory $env(LG_ENTRY)
	set curdirname [file dirname $curdirectory]

	set titolo "Corrent user directory: $env(LG_ENTRY) - Select new user directory"
	set curdirectory [tk_chooseDirectory -parent . -initialdir $curdirname -mustexist yes -title $titolo ]
	if { $curdirectory == "" } { 
        return
	}


       if {![file exists $curdirectory/libgraph/connect.dat]} {
         tk_messageBox -message "switchuser: $curdirectory it is NOT correct" -type ok	
         return
       }

       
       set mex [tk_messageBox -icon question -type yesno \
         		-title Question -parent . -message "Changing user directory to $curdirectory. Proceed?" ]  
       if {$mex == "no"} {	
       tk_messageBox -message "User directory NOT changed." -type ok	
       return
       } 

	set repathULTIMO {HKEY_CURRENT_USER\Environment}
###	set repathULTIMO {HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment}
	registry set $repathULTIMO "LG_ENTRY" $curdirectory

#	set repath1 {HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment}
#	set repath2 {HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Control\Session Manager\Environment}
#	registry set $repath1 "LG_ENTRY" $curdirectory
#	registry set $repath2 "LG_ENTRY" $curdirectory
#set repathULTIMO {HKEY_CURRENT_USER\Environment}
#registry set $repathULTIMO "LG_ENTRY" $curdirectory

#### non funziona con package regitry 1.0:  registry broadcast "Environment", funziona con la 1.1
#### utilizzo un programma fatto ad hoc che notifica il cambiamento delle variabli 
#### ambiente a tutto il sistema
	set notifica "$env(LG_TOOLS)/reg_broadcast.exe" 
	exec $notifica &

	tk_messageBox -message "User directory changed to $curdirectory.\n Legopc is closing, Please restart" -type ok

#	set comm1 [info nameofexecutable]
#	set comm2 "$env(LG_TIX)/legopc.tix"
#	exec $comm1 -f $comm2 &

	WarnYou exit

}



###################################


proc ssopt_linux {} {

# lettura del file delle opzioni lg3.inp

     if [file exists lg3.inp] {
        set f [checkopen lg3.inp r]
     } else {
        set f [checkopen $::env(LEGO_BIN)/lg3.inp r]
     }
        gets $f ::stampe
        gets $f ::tolerance
	gets $f ::terzo
        close $f


    set w .opt_toler
    toplevel $w; wm transient $w ""
    frame $w.top -border 1 -relief raised




    tixLabelEntry $w.top.a -label "Steady state tolerance: " \
	-options {
	    entry.width 10
	    label.width 20
	    label.anchor e
	    entry.textVariable ::tolerance
	}

    pack $w.top.a  -side top -anchor w

   # Use a ButtonBox to hold the buttons.
    #
    tixButtonBox $w.box -orientation horizontal
    $w.box add ok     -text Ok     -underline 0 -command \
    " opt_okcmd ; destroy $w  " \
	-width 6
    $w.box add cancel -text Cancel -underline 0 -command "destroy $w" \
	-width 6

    pack $w.box -side bottom -fill x
    pack $w.top -side top -fill both -expand yes


#    bind $w <Destroy> exit


}

proc opt_okcmd {} {

        set f [checkopen lg3.inp w]
        puts $f $::stampe
        puts $f $::tolerance
        puts $f $::terzo
puts "legopc.tix: tolerance=$::tolerance"

        close $f

}








####################################
proc ssopt {} {
global calcmode jacob damp tolerance peso0 epsilon percent
#tk_messageBox -icon warning -message "calcmode:$calcmode" -type ok
# calcmode 1=MA28   0=Schmidt
set calcmode 1
     if [file exists lg3.inp] {
        set f [checkopen lg3.inp r]
        gets $f line
        gets $f line
        if {[string first "3" $line] >= 0} {
           set jacob 1
        }
        gets $f tolerance
        gets $f line
        gets $f damp
        if {$damp != 0} {
           gets $f percent
        }
        set calcmode 1
        if {$line == "S"} {
         set calcmode 0
         gets $f peso0
         gets $f epsilon
        }
        close $f
    }
    catch {destroy .config}
    toplevel .config   
    wm title .config "Steady State Configuration"
    wm iconname .config "CFGs"
    frame .config.frm
    frame .config.frm.toll
    label .config.frm.toll.lab -width 17 -justify left -pady 3m -font "Times 12" \
                                         -text "Tolerance " -anchor w
    entry .config.frm.toll.ent -width 20 -textvariable tolerance
    pack .config.frm.toll.lab .config.frm.toll.ent -side left -padx 2m -padx 2m
    pack .config.frm.toll -side top -padx 2m -padx 2m -anchor w
    frame .config.frm.p0
    label .config.frm.p0.lab -width 17 -justify left -pady 3m -font "Times 12" \
                                       -text "Zero weight " -anchor w
    entry .config.frm.p0.ent -width 20 -textvariable peso0
    pack .config.frm.p0.lab .config.frm.p0.ent -side left -padx 2m -padx 2m
    pack .config.frm.p0 -side top -padx 2m -padx 2m -anchor w
    frame .config.frm.eps
    label .config.frm.eps.lab -width 17 -justify left -pady 3m -font "Times 12" \
                                        -text "Epsilon " -anchor w
    entry .config.frm.eps.ent -width 20 -textvariable epsilon
    pack .config.frm.eps.lab .config.frm.eps.ent -side left -padx 2m -padx 2m
    pack .config.frm.eps -side top -padx 2m -padx 2m -anchor w
    if {$calcmode == 1} {
     .config.frm.p0.ent configure -state disabled
     .config.frm.eps.ent configure -state disabled
    }
    frame .config.frm.perc
    label .config.frm.perc.lab -width 17 -justify left -pady 3m -font "Times 12" \
                                        -text "Damping p.u. (if any)" -anchor w
    entry .config.frm.perc.ent -width 20 -textvariable percent
    pack .config.frm.perc.lab .config.frm.perc.ent -side left -padx 2m -padx 2m
    pack .config.frm.perc -side top -padx 2m -padx 2m -anchor w
    frame .config.frm.smorz
    radiobutton .config.frm.smorz.no -text "No damping" -variable damp -relief flat -value 0
    radiobutton .config.frm.smorz.ec -text "Exceedings" -variable damp -relief flat -value 1
    radiobutton .config.frm.smorz.al -text "All vars"   -variable damp -relief flat -value 2
    frame .config.frm.calcmode
    radiobutton .config.frm.calcmode.gr -text "Gram Schmidt" -variable calcmode -relief flat -value 0 -command {
             if {$calcmode == 1} {
              .config.frm.p0.ent configure -state disabled
              .config.frm.eps.ent configure -state disabled
             } else {
              .config.frm.p0.ent configure -state normal
              .config.frm.eps.ent configure -state normal
             }
      }
    radiobutton .config.frm.calcmode.ma -text "MA28" -variable calcmode -relief flat -value 1 -command {
             if {$calcmode == 1} {
              .config.frm.p0.ent configure -state disabled
              .config.frm.eps.ent configure -state disabled
             } else {
              .config.frm.p0.ent configure -state normal
              .config.frm.eps.ent configure -state normal
            }
      }
    pack .config.frm.smorz.no .config.frm.smorz.ec .config.frm.smorz.al -side left \
                                                        -padx 3m -pady 2m
    pack .config.frm.smorz -side top -padx 4m -padx 4m -anchor w
    pack .config.frm.calcmode -side top -padx 4m -padx 4m -anchor w
    pack .config.frm.calcmode.gr .config.frm.calcmode.ma -side left -padx 10m -pady 2m
    frame .config.frm.jaco
    label .config.frm.jaco.text -width 17 -justify left -pady 3m -font "Times 12" \
                                          -text "Print jacobian " -anchor w
    checkbutton .config.frm.jaco.chb -variable jacob -relief flat -anchor w
    pack .config.frm.jaco.text .config.frm.jaco.chb -side left -padx 2m
    pack .config.frm.jaco -side top -padx 2m -padx 2m -anchor w
    frame .config.frm.butt
    button .config.frm.butt.ok -text "OK" -command {
        destroy .config
        puts "ciao"
        set f [checkopen lg3.inp w]
        puts $SLV
        puts $f "SI"
        if {$jacob == 0} {
           puts $f "1 2"
        } else {
           puts $f "1 2 3"
        }
        puts $f $tolerance
        if {$calcmode == 0} {
         puts $f "S"
        } else {
         puts $f "M"
        }
        puts $f $damp
        if {$damp != 0} {
           puts $f $percent
        }
        if {$calcmode == 0} {
         puts $f $peso0
         puts $f $epsilon
        }
        puts $f "SI"
        close $f
    }
    button .config.frm.butt.default -text "Default" -command {
        destroy .config
        file copy -force $SLV/lg3.def lg3.inp
    }
    button .config.frm.butt.canc  -text "Cancel" -command "destroy .config"
    pack .config.frm.butt.ok .config.frm.butt.default .config.frm.butt.canc \
                          -side left -expand 1
    pack .config.frm.butt -padx 2m -pady 2m -fill x
    pack .config.frm -pady 2m -padx 2m
#tk_messageBox -icon warning -message "ssopt: $calcmode" -type ok

}


proc portSelect {c} {
	global sPortOrigImage sPortId sPortType sPortDir sBlockId
	global connlist extname idconn clines cvardef
	global modified needbuild
	if {[llength [$c find withtag startPort]] == "0"} { # no port selected
		if {[lsearch -exact [$c gettags current] output] == "-1"} {
			bell
			return
		}
		if {[lsearch -exact [$c gettags current] busy] != "-1"} {
			bell
			return
		}
		set sBlockId [lindex [$c gettags current] 1]
		#tk_messageBox -icon error -message "sBlockId = $sBlockId"		
		set sPortId [lindex [$c gettags current] 0]
		set sPortType [lindex [$c gettags current] [lsearch [$c gettags current] *ptype]]
		set anchor [$c itemcget $sPortId -anchor]
		switch $anchor {
			n {set sPortDir s}
			e {set sPortDir w}
			s {set sPortDir n}
			w {set sPortDir e}
		}
		$c addtag startPort withtag current
		set sPortOrigImage [$c itemcget current -image]
		$c itemconfigure current -image portActive
		return
	}
	if {[llength [$c find withtag startPort]] == "1"} { # starting port selected
		if {[$c find withtag startPort] != [$c find withtag current] } { # join ports
			if {[lsearch -exact [$c gettags current] $sPortType] == "-1"} {
				bell
				return
			}
			if {[lsearch -exact [$c gettags current] input] == "-1"} {
				bell
				return
			}
			if {[lsearch -exact [$c gettags current] busy] != "-1"} {
				bell
				return
			}
			# insert here setting of directions and of ports
			set eBlockId [lindex [$c gettags current] 1]
			#tk_messageBox -icon error -message "eBlockId = $eBlockId"
			if {$eBlockId == $sBlockId} {
				bell
				return
			}

			set ePortId [lindex [$c gettags current] 0]
			set linktag link$sPortId.$ePortId
			set anchor [$c itemcget $ePortId -anchor]
			switch $anchor {
				n {set ePortDir s}
				e {set ePortDir w}
				s {set ePortDir n}
				w {set ePortDir e}
			}
			set tycon [string range $sPortType 0 3]
			portJoin $linktag $c $sPortId $sPortDir $ePortId $ePortDir $tycon
#vengono aggiunti i tag di connessione...
			set revlinktag link$ePortId.$sPortId
			$c addtag $revlinktag withtag $linktag
			$c itemconfigure $linktag -fill $clines($tycon,color)
			$c addtag ${tycon}_ltype withtag $linktag
			$c addtag busy withtag $sPortId
			$c addtag busy withtag $ePortId
			$c addtag connwith.$ePortId withtag $sPortId
			$c addtag connwith.$sPortId withtag $ePortId
# debug tk_messageBox -message "portSelect: linktag=$linktag\n revlinktag=$revlinktag tycon_ltype=${tycon}_ltype\n sPortId=$sPortId ePortId=$ePortId\n connwith.$ePortId connwith.$ePortId"
		set modified 1
		set needbuild 1
		}
		$c itemconfigure [$c find withtag startPort] -image $sPortOrigImage
		$c dtag startPort
		return
	}
}


proc itemEnter {c} {
	global oldeimage infoMode helpPath
# tk_messageBox -icon warning -message "itemEnter: $helpPath" -type ok
	set ms 1000
	set lc [$c bbox current] 
	set x [lindex $lc 2]
	set y [lindex $lc 1]

		switch $infoMode {
			none {
				#set curmod [$c find withtag current]
				#set oldeimage [$c itemcget $curmod -image]
				#$c itemconfigure $curmod -image ${oldeimage}h
				#after $ms $c itemconfigure $curmod -image $oldeimage
			}
			name {
				set pisqu [file rootname [lindex [$c gettags current] [lsearch [$c gettags current] *.name]]]; # here you must retrieve name info
#				set pisqu [file rootname [lindex [$c gettags all ] [lsearch [$c gettags all] *.name]]]; # here you must retrieve name info		
#tk_messageBox -icon warning -message $pisqu -type ok
				set tid [$c create text $x $y -text $pisqu -tags {infoitem}]
				set lc [$c bbox $tid] 
				set x1 [lindex $lc 0]
				set y1 [lindex $lc 1]
				set x2 [lindex $lc 2]
				set y2 [lindex $lc 3]
				$c create rectangle $x1 $y1 $x2 $y2 -fill yellow -tags {infoitem}
				$c raise $tid
				after $ms $c delete infoitem
			}
			class {
				set pisqu [file rootname [lindex [$c gettags current] [lsearch [$c gettags current] *.cls]]] 
				if {$pisqu == ""} {
                         set pisqu [$c itemcget current -image]
                        }
				set tid [$c create text $x $y -text $pisqu -tags {infoitem}]
				set lc [$c bbox $tid] 
				set x1 [lindex $lc 0]
				set y1 [lindex $lc 1]
				set x2 [lindex $lc 2]
				set y2 [lindex $lc 3]
				$c create rectangle $x1 $y1 $x2 $y2 -fill yellow -tags {infoitem}
				$c raise $tid
				after $ms $c delete infoitem
			}
			help {
                        set classname [string range [$c itemcget [$c find withtag current] -image] 0 5]
				set hlpid [checkopen [file join $helpPath $classname.tch] r]
				set tid [$c create text $x $y -text [read -nonewline $hlpid] \
					-font helpFont -width 120 -tags {infoitem}]
				set lc [$c bbox $tid] 
				set x1 [lindex $lc 0]
				set y1 [lindex $lc 1]
				set x2 [lindex $lc 2]
				set y2 [lindex $lc 3]
				$c create rectangle $x1 $y1 $x2 $y2 -fill white -tags {infoitem}
				$c raise $tid
				close $hlpid
				after $ms $c delete infoitem
			}
		}
}

proc itemLeave {c} {
	global oldeimage infoMode

		switch $infoMode {
			none {$c itemconfigure current -image $oldeimage}
			name {$c delete infoitem}
			class {$c delete infoitem}
			help {$c delete infoitem}
		}
}

proc itemDelete {c} {
	global modified needbuild
####	set mylist [$c gettags current]
####tk_messageBox -message "itemDelete: $mylist"
####	set mytag [lindex $mylist [lsearch $mylist id* ]]
####	
####	if {$mytag == "" } { set mytag $::currTid }
        set mytag $::currTid

	
	set mylist [$c find withtag $mytag]
#tk_messageBox -message "itemDelete: tutto\n mytag=$mytag\n $mylist"

	foreach item $mylist {
#tk_messageBox -message "itemDelete: item=$item\n [$c gettags $item]"
                set tags [$c gettags $item]
		if {[lsearch -exact $tags busy] != -1} {
			set tipo [lindex $tags 5]
			set stag [lindex $tags 0]
			set etag [lindex [split [lindex $tags [lsearch $tags connwith*]] . ] end ]

			if { $tipo == "output" } {
				set nome_link "link$stag.$etag"
			} else {
				set nome_link "link$etag.$stag"								
				}
				
#			tk_messageBox -icon warning -message "This module is linked.\nBreak connection first,\nthen delete it.\n $tags\n $nome_link" -type ok
			
			 set ::currTags $nome_link
			 linkDelete $c
###			return
		}
	}
	foreach item $mylist {$c delete $item}
	set modified 1
	set needbuild 1
}


proc itemStartDrag {c x y} {
#
#se mult=1  selezione multipla
#
#	tk_messageBox -message "itemStartDrag: c=$c x=$x y=$y"
# debug   puts "itemStartDrag: c=$c x=$x y=$y"
global lastX lastY mult_sel

# inibisco il delete della selezione...
set ::inib 1

set tid [lindex [$c gettags current] 0]
if {$tid == ""} {set tid $::currTid}

if {$mult_sel == 0} {
	      catch { $c delete selectitem
        unset  ::select_list
        $c dtag selezionato}

#costruisco il rettangolo di selezione
        set lc [$c bbox $tid] 
        set x1 [expr [lindex $lc 0] - 5]
        set y1 [lindex $lc 1]
        set x2 [expr [lindex $lc 2] + 5]
        set y2 [lindex $lc 3]
        set selectitemId [$c create rectangle $x1 $y1 $x2 $y2  -tags {selectitem}]
        set  ::select_list $tid 
        lappend ::select_list $selectitemId
} else {
         set risul -1
         
         if [info exists ::select_list] {set risul [lsearch -exact $::select_list $tid]}
         
         if { $risul != -1} {
         #	tk_messageBox -icon warning -message "itemStartDrag_mult C'e gi�" -type ok
         	set x [$c canvasx $x]
         	set y [$c canvasy $y]
         
         	set lastX $x
         	set lastY $y
         	
         	return
         }
         #costruisco il rettangolo di selezione
         set lc [$c bbox $tid] 
         set x1 [expr [lindex $lc 0] - 5]
         set y1 [lindex $lc 1]
         set x2 [expr [lindex $lc 2] + 5]
         set y2 [lindex $lc 3]
         set selectitemId [$c create rectangle $x1 $y1 $x2 $y2  -tags {selectitem}]
         lappend ::select_list $tid $selectitemId
}	
		
	global infoMode oldinfoMode showon
	set oldinfoMode $infoMode
	set infoMode none
#	$c raise [lindex [$c gettags current] 0]
	global startX startY
	set lastX [$c canvasx $x]
	set lastY [$c canvasy $y]
	set startX [$c canvasx $x]
	set startY [$c canvasy $y]
#	catch [ ShowNames $c 1 ]
#	if { $showon == 2 } {
#       		catch [ ShowNames $c 2 ]
#	}
#	if { $showon == 3 } {
#       		catch [ ShowNames $c 3 ]
#	}
}

#proc itemStartDrag_mult {c x y} {
#puts "itemStartDrag_mult: c=$c x=$x y=$y"
#global lastX lastY
#
## inibisco il delete della selezione...
#set ::inib 1
#
#set tid [lindex [$c gettags current] 0]
#if {$tid == ""} {set tid $::currTid}
#set risul -1
#catch [set risul [lsearch -exact $::select_list $tid]]
#
#if { $risul != -1} {
##	tk_messageBox -icon warning -message "itemStartDrag_mult C'e gi�" -type ok
#	set x [$c canvasx $x]
#	set y [$c canvasy $y]
#
#	set lastX $x
#	set lastY $y
#	
#	return
#}
##costruisco il rettangolo di selezione
#set lc [$c bbox $tid] 
#set x1 [expr [lindex $lc 0] - 5]
#set y1 [lindex $lc 1]
#set x2 [expr [lindex $lc 2] + 5]
#set y2 [lindex $lc 3]
#set selectitemId [$c create rectangle $x1 $y1 $x2 $y2  -tags {selectitem}]
#lappend ::select_list $tid $selectitemId
#
#	global infoMode oldinfoMode showon
#	set oldinfoMode $infoMode
#	set infoMode none
##	$c raise [lindex [$c gettags current] 0]
#	global startX startY
#	set lastX [$c canvasx $x]
#	set lastY [$c canvasy $y]
#	set startX [$c canvasx $x]
#	set startY [$c canvasy $y]
##	catch [ ShowNames $c 1 ]
##	if { $showon == 2 } {
##       		catch [ ShowNames $c 2 ]
##	}
##	if { $showon == 3 } {
##       		catch [ ShowNames $c 3 ]
##	}
#}
#

proc itemStartDrag_mult_all { c tutto} {

# se tutto=1 si leleziona tutto se 0 si seleziona il contenuto di ::select_list

#	tk_messageBox -message "itemStartDrag: c=$c x=$x y=$y"
global lastX lastY

set x 0
set y 0

if { $tutto == 1 } { set mylist_all [$c find withtag module]
catch {$c delete selectitem}
catch { unset  ::select_list }
} else { set mylist_all $::select_list;unset ::select_list}                

#debug tk_messageBox -message "itemStartDrag_mult_all: $mylist_all"

foreach curr $mylist_all {
	 
set tid [lindex [$c gettags $curr ] 0]
#costruisco il rettangolo di selezione
set lc [$c bbox $tid] 
set x1 [expr [lindex $lc 0] - 5]
set y1 [lindex $lc 1]
set x2 [expr [lindex $lc 2] + 5]
set y2 [lindex $lc 3]
set selectitemId [$c create rectangle $x1 $y1 $x2 $y2  -tags {selectitem}]
lappend ::select_list $tid $selectitemId

#tk_messageBox -message "itemStartDrag: c=$c x=$x y=$y\n tid=$tid\n $::select_list\n lunghezza= [llength $::x_select_list] lungh_lastx=[llength $::lastx_select_list] \n lunghezza lista=[llength $::select_list] "

	global infoMode oldinfoMode showon
	set oldinfoMode $infoMode
	set infoMode none
	$c raise [lindex [$c gettags current] 0]
	global lastX lastY startX startY
	set lastX [$c canvasx $x]
	set lastY [$c canvasy $y]
	set startX [$c canvasx $x]
	set startY [$c canvasy $y]

}

}





set ::inib 0
set ::cisono 0
proc delete_sel { c } {
puts "delete_sel:"	
	#if { $::inib == 1 } { set ::inib 0; return } 
#        if {$::cisono == 1 } {
               catch {
               $c delete selectitem
               unset  ::select_list
               $c dtag selezionato}
#               }

}


proc itemDrag {c x y} {
	global lastX lastY modified needbuild showon
	set x [$c canvasx $x]
	set y [$c canvasy $y]
# set altro  [$c find all ] 
#tk_messageBox -message "buildLegoFiles altro: $altro"
#set altro2 [$c gettags current]
# tk_messageBox -message "buildLegoFiles altro2: $altro2"
#foreach altro  [lindex [$c gettags current] 0]  {
#tk_messageBox -message "itemDrag altro: $altro"
# }


	set curmodule [lindex [$c gettags current] 0]
#tk_messageBox -message "itemDrag curmodule: $curmodule"	
	
# foreach altro  [$c gettags all ] {
#tk_messageBox -message "itemDrag altro: $altro"
# }
	$c move $curmodule [expr $x-$lastX] [expr $y-$lastY]
	set lastX $x
	set lastY $y

	# update links
	set moduleports [$c find withtag $curmodule]
	foreach port $moduleports {
		if {[lsearch -exact [$c gettags $port] busy] == "-1"} {
			continue
		}
		set connportid [lindex [split [lindex [$c gettags $port] [lsearch [$c gettags $port] connwith*]] . ] end ]
		set linktag linkid$port.$connportid

		if {[lsearch -exact [$c gettags $port] output] != "-1"} {
			set sPort $port
			set ePort $connportid
		} else {
			set ePort $port
			set sPort $connportid
		}

		set anchor [$c itemcget $sPort -anchor]
		switch $anchor {
			n {set sPortDir s}
			e {set sPortDir w}
			s {set sPortDir n}
			w {set sPortDir e}
		}
		set anchor [$c itemcget $ePort -anchor]
		switch $anchor {
			n {set ePortDir s}
			e {set ePortDir w}
			s {set ePortDir n}
			w {set ePortDir e}
		}
		portFollow $linktag $c $sPort $sPortDir $ePort $ePortDir
	}
	catch { ShowNames $c 1 }
	if { $showon == 2 } {
       		catch { ShowNames $c 2 }
	}
	if { $showon == 3 } {
       		catch { ShowNames $c 3 }
	}
	set modified 1
#	set needbuild 1
}


proc itemDrag_mult {c xx yy} {
	global lastX lastY modified needbuild showon
#debug    puts  "itemDrag 1 xx=$xx: yy=$yy "
	set xx [$c canvasx $xx]
	set yy [$c canvasy $yy]
if { $::styledrag != 0 } { nascondi_links $c 1 }
set ii 0
set dx [expr $xx-$lastX]
set dy [expr $yy-$lastY]
####puts "x=$xx lastX=$lastX dx=$dx         y=$yy lastY=$lastY dy=$dy"

set lastX $xx
set lastY $yy
foreach curmodule $::select_list  {

#        set x [lindex $::x_select_list $ii]
#        set y [lindex $::y_select_list $ii]
#        set newx [expr $x+$dx]
#        set newy [expr $y+$dy]
	$c move $curmodule $dx $dy

#set ::x_select_list [lreplace $::x_select_list $ii $ii $newx]
#set ::y_select_list [lreplace $::y_select_list $ii $ii $newy]


incr ii
if { $::styledrag == 0 } {
	# update links
	set moduleports [$c find withtag $curmodule]
#tk_messageBox -message "itemDrag_mult: curmodule=$curmodule\n moduleports=$moduleports"
	foreach port $moduleports {
# debug tk_messageBox -message "itemDrag_mult: curmodule=$curmodule\n moduleports=$moduleports\n port=$port\n [$c gettags $port]"
		if {[lsearch -exact [$c gettags $port] busy] == "-1"} {
			continue
		}
		set connportid [lindex [split [lindex [$c gettags $port] [lsearch [$c gettags $port] connwith*]] . ] end ]
		set linktag linkid$port.$connportid

		if {[lsearch -exact [$c gettags $port] output] != "-1"} {
			set sPort $port
			set ePort $connportid
		} else {
			set ePort $port
			set sPort $connportid
		}

		set anchor [$c itemcget $sPort -anchor]
		switch $anchor {
			n {set sPortDir s}
			e {set sPortDir w}
			s {set sPortDir n}
			w {set sPortDir e}
		}
		set anchor [$c itemcget $ePort -anchor]
		switch $anchor {
			n {set ePortDir s}
			e {set ePortDir w}
			s {set ePortDir n}
			w {set ePortDir e}
		}
		portFollow $linktag $c $sPort $sPortDir $ePort $ePortDir
	}
	catch { ShowNames $c 1 }
	if { $showon == 2 } {
       		catch { ShowNames $c 2 }
	}
	if { $showon == 3 } {
       		catch { ShowNames $c 3 }
	}
}
}
	set modified 1
#	set needbuild 1
}


proc drawlinks { c } {
	global lastX lastY modified needbuild showon

foreach curmodule $::select_list  {

	# update links
	set moduleports [$c find withtag $curmodule]
	foreach port $moduleports {
		if {[lsearch -exact [$c gettags $port] busy] == "-1"} {
			continue
		}
		set connportid [lindex [split [lindex [$c gettags $port] [lsearch [$c gettags $port] connwith*]] . ] end ]
		set linktag linkid$port.$connportid

		if {[lsearch -exact [$c gettags $port] output] != "-1"} {
			set sPort $port
			set ePort $connportid
		} else {
			set ePort $port
			set sPort $connportid
		}

		set anchor [$c itemcget $sPort -anchor]
		switch $anchor {
			n {set sPortDir s}
			e {set sPortDir w}
			s {set sPortDir n}
			w {set sPortDir e}
		}
		set anchor [$c itemcget $ePort -anchor]
		switch $anchor {
			n {set ePortDir s}
			e {set ePortDir w}
			s {set ePortDir n}
			w {set ePortDir e}
		}
		portFollow $linktag $c $sPort $sPortDir $ePort $ePortDir
	}
	catch { ShowNames $c 1 }
	if { $showon == 2 } {
       		catch { ShowNames $c 2 }
	}
	if { $showon == 3 } {
       		catch { ShowNames $c 3 }
	}
}
}




proc itemFinishDrag {c x y} {
	global startX startY oldinfoMode infoMode
      if [info exists oldinfoMode] {
	   set infoMode $oldinfoMode
      }
if { $::styledrag == 0 } { return }
drawlinks $c
nascondi_links $c 0
}

proc itemAdd {c x y} {
	global modified needbuild
	global curTool curLibPath progNumb progName wsXsiz wsYsiz
#tk_messageBox -message "itemAdd: progNumb=$progNumb"
      if ![info exists curLibPath] return
	set fromfile "no"
	# take care of scrolling state
	set x [expr $x + [lindex [$c xview] 0] * $wsXsiz]
	set y [expr $y + [lindex [$c yview] 0] * $wsYsiz]
      set GIForient "n"
      set idclass $curTool
	source [file join $curLibPath $curTool.tcl]
	set modified 1
	set needbuild 1
#tk_messageBox -message "4 $progNumb\n $curLibPath \n $curTool"
#tk_messageBox -message "itemAdd: mymodId=$mymodId"
}

proc itemAddFromfile {c x y ctool libp prnum ori curname} {
global progNumb
	set ff_progNumb $prnum
	set fromfile "yes"
	set GIForient $ori
	set idclass $ctool
	set mlpath $libp


	while {[$c find withtag $ff_progNumb.name] != {}} {
		set ff_progNumb [string range ${progNumb}____ 0 3]
		incr progNumb
		set enval $progNumb
		if {[string length $enval] > 4} {set enval [string range $enval 0 3]}
		if {[string length $enval] < 4} {set enval [string range ${enval}____ 0 3]}
		set ff_progNumb [string toupper $enval]
		set prnum $ff_progNumb
	
	
	}
    if { $curname != "?" } { aggiungi_eccedi14 $curname $ff_progNumb }

	source [file join $libp $ctool.tcl]
	set modified 1
	set needbuild 1

	return $mymodId

}


proc finishJoin {c} {
	global cucu
	global modified needbuild
	$c itemconfigure pull -stipple ""
	set modified 1
	set needbuild 1
}

#proc panic_if_desired {} {
#
#    set res [tk_dialog .panic "Panic?" "Should we panic yet?" \
#             question 0 "Okay!" "Not sure" "Not yet"]
#
#    switch $res {
#        0 { puts "PANIC!!!" }
#        1 { panic_if_desired }
#        2 { } # do nothing
#    }
#}
#


proc plotPS {c} {
	global env curFileName wsXsiz wsYsiz modalita
	#overwrite pixmap image with bitmaps (yeck)
#  trasformazione delle icone a colori in icone bianco/nero.( GUAG: perch�???)		
#	foreach pitem [$c find withtag module] {
#           	set modname [$c itemcget $pitem -image]
#		set lc [$c bbox $pitem] 
#		set x1 [lindex $lc 0]
#		set y1 [lindex $lc 1]
#		set x2 [lindex $lc 2]
#		set y2 [lindex $lc 3]
#		$c create bitmap $x1 $y1 -bitmap @[file join $env(LG_XBM) $modname.xbm] \
#			-tags {tempPS} -anchor nw -background white
#	}
#
#	foreach pitem [$c find withtag port] {
#		set portname [$c itemcget $pitem -image]
#		set lc [$c bbox $pitem] 
#		set x1 [lindex $lc 0]
#		set y1 [lindex $lc 1]
#		set x2 [lindex $lc 2]
#		set y2 [lindex $lc 3]
#		$c create bitmap $x1 $y1 -bitmap @[file join $env(LG_PIXMAPS) $portname.xbm] \
#			-tags {tempPS} -anchor nw -background white
#	}
#
	set ruota [expr $wsXsiz > $wsYsiz]
	puts $ruota
	set psfile "[file rootname $curFileName].ps"
	puts $psfile
	set largh [expr $wsXsiz + 0]
	set altez  [expr $wsYsiz + 0]
#	set altez $wsYsiz 
update
#if {$modalita == 1} { tk_messageBox -icon info -type ok -message " sono in c"} else {tk_messageBox -icon info -type ok -message " sono in c2"}
#tk_messageBox -icon info -type ok -message "$largh  $altez"

#	$c postscript -width $wsXsiz -height $wsXsiz -pagewidth 210m -pageheight 297m \
#		 -colormode color -file $psfile
	$c postscript  -width $largh -height $altez  \
		 -pageanchor sw  -colormode color -file $psfile
##	$c postscript   -width $largh -height $altez  -pagewidth 210m -pageheight 297m \
##		 -pageanchor nw -pagey 800 -pagex 0 -colormode color -file $psfile



#	$c postscript  -pagewidth 210m -pageheight 297m \
#	$c postscript -colormode color -file $psfile
#set mex "wsXsiz=$wsXsiz   wsYsiz=$wsYsiz "
#tk_messageBox -icon info -type ok -message $mex


	#erase temporary PS items
#	$c delete tempPS
	set mex "Created postscript file: $psfile"
	tk_messageBox -icon info -type ok -message $mex

}


# "ask for module name" dialog
proc inputModName {c x y} {
	global progName mnamedone enval progNumb
	set mnamedone 0
	set mndlg $c.modname
	catch {destroy $mndlg}
	frame $mndlg -relief raised
	set enval $progNumb
	entry $mndlg.mname -relief sunken -width 4 -font entryFont -textvariable enval
	label $mndlg.askl -text "insert name (4 char)"
	pack $mndlg.askl $mndlg.mname -side top
	button $mndlg.dismiss -text Accept -command "set mnamedone 1"
	pack $mndlg.dismiss -side bottom
	set wid [$c create window $x $y -window $mndlg]
	focus $mndlg.mname
	$mndlg.mname selection range 0 3
	bind $mndlg.mname <Return> "set mnamedone 1"

#	grab $mndlg
#bell
#---nuovo
	if {[string length $enval] > 4} {set enval [string range $enval 0 3]}
	if {[string length $enval] < 4} {set enval [string range ${enval}____ 0 3]}
	set progName [string toupper $enval]
	while {[$c find withtag $progName.name] != {}} {
		set progName [string range ${progNumb}____ 0 3]
		incr progNumb
		set enval $progNumb
		if {[string length $enval] > 4} {set enval [string range $enval 0 3]}
		if {[string length $enval] < 4} {set enval [string range ${enval}____ 0 3]}
		set progName [string toupper $enval]
	}

        set ok1 1
	while { $ok1 } {
	vwait mnamedone
	   if {[string length $enval] > 4} {set enval [string range $enval 0 3]}
	   if {[string length $enval] < 4} {set enval [string range ${enval}____ 0 3]}
	   set progName [string toupper $enval]
	   if { [$c find withtag $progName.name] != {} } {
		tk_messageBox -icon info -message "Name already assigned!" -type ok
		set enval $progNumb
	   } else {
	   set ok1 0
	   grab release $mndlg
	   $c delete $wid
	   }
	}
#--- fine  nuovo

#---vecchia maniera
#	vwait mnamedone
#	grab release $mndlg
#	$c delete $wid
#	if {[string length $enval] > 4} {set enval [string range $enval 0 3]}
#	if {[string length $enval] < 4} {set enval [string range ${enval}____ 0 3]}
#	set progName [string toupper $enval]
#
#	while {[$c find withtag $progName.name] != {}} {
#		set progName [string range ${progNumb}____ 0 3]
#		tk_messageBox -icon info -message "Name already assigned: smart substitution on" -type ok
#		incr progNumb
#	}
#


}


proc createPal {} {
	global env palId curLibPath pixmapPath curTool
	#   Type names		Extension(s)	Mac File Type(s)
	set types {
		{"Libraries"		{.lib}	}
		{"All files"		*}
	}

	set file [tk_getOpenFile -filetypes $types -parent . -initialdir $env(LG_LIBRARIES)]
	if {$file == ""} {return}
	set dirname [file dirname "$file"]
	set olddir [pwd]
	incr palId
	toplevel .pal$palId

#	frame .pal$palId.frm
#	scrollbar .pal$palId.frm.scroll -command ".pal$palId.frm yview"
#	set pal  .pal$palId.frm

	set pal0 .pal$palId
	wm title $pal0 [file rootname [file tail $file]]



	bind $pal0 <1> "set curLibPath \"$dirname\""
	set curLibPath $dirname

tixScrolledWindow $pal0.canv 
pack $pal0.canv -expand yes -fill both -padx 10 -pady 10 -side left
set pal [$pal0.canv subwidget window]

	cd "$dirname"
	set items [glob *.gif]
	set row 0
	set column 0
	foreach item $items {
            set modist [file rootname $item]
            set modisttesto $modist 
            set ifori [string range $modist end end]
            if {$ifori == "n"} {
             set modnoext [string trimright $modist $ifori]
#tk_messageBox -type ok -icon error  -message "createpal: modist=$modist modnoext=$modnoext"
             image create photo $modist -file $modist.gif
             radiobutton $pal.$modnoext  -indicatoron 0 -variable curTool -value $modnoext 

#aggiungo il nome all'icona
  	     	set compo1 [image create compound -window $pal.$modnoext ]
		$compo1 add text -text $modisttesto
		$compo1 add line 
		$compo1 add image -image $modist 
		$pal.$modnoext config -image $compo1
#--------
		 grid $pal.$modnoext -in $pal -row $row -column $column -sticky news

		 bind $pal.$modnoext <Button-3> {
			set window_name [lindex [split %W .] end]
			toplevel .tch 
			wm maxsize .tch 40 10
			wm title .tch "$window_name"
			text .tch.txt -relief sunken -bd 2 -setgrid 1 -background yellow
			.tch.txt tag configure first -font {Courier 12 bold} -lmargin1 6m \
					-lmargin2 6m -rmargin 6m -wrap word
			.tch.txt tag configure others -font {Courier 10} -lmargin1 6m \
					-lmargin2 6m -rmargin 6m -wrap word
		      if [file exists $env(LG_HELP)/$window_name.tch ] {
			set idf [open $env(LG_HELP)/$window_name.tch r]
			.tch.txt insert end "\n[gets $idf]\n\n" first
			while {[eof $idf] != 1} {
				.tch.txt insert end "[gets $idf]\n" others
			}
			close $idf
			pack .tch.txt -expand yes -fill both
		       }
		 }
		 bind $pal.$modnoext <ButtonRelease-3> "destroy .tch"
            } elseif {$ifori == "s"} {
             image create photo $modist -file $modist.gif
             continue
            } elseif {$ifori == "e"} {
             image create photo $modist -file $modist.gif
             continue
            } elseif {$ifori == "w"} {
             image create photo $modist -file $modist.gif
             continue
            } else {
   tk_messageBox -type ok -icon error  -message "createpal: attenzione! \nCaricata icona $modist senza orientamento: \ndeve essere n,s,w oppure e"
		 set modnoext $modist
             image create photo $modnoext -file $modnoext.gif
             radiobutton $pal.$modnoext -image $modnoext -indicatoron 0 -variable curTool -value $modnoext
		 grid $pal.$modnoext -in $pal -row $row -column $column -sticky news

		 bind $pal.$modnoext <Button-3> {
			set window_name [lindex [split %W .] end]
			toplevel .tch 
			wm maxsize .tch 40 10
			wm title .tch "$window_name"
			text .tch.txt -relief sunken -bd 2 -setgrid 1 -background yellow
			.tch.txt tag configure first -font {Courier 12 bold} -lmargin1 6m \
					-lmargin2 6m -rmargin 6m -wrap word
			.tch.txt tag configure others -font {Courier 10} -lmargin1 6m \
					-lmargin2 6m -rmargin 6m -wrap word
                        if [file exists $env(LG_HELP)/$window_name.tch ] {
			set idf [open $env(LG_HELP)/$window_name.tch r]
			.tch.txt insert end "\n[gets $idf]\n\n" first
			while {[eof $idf] != 1} {
				.tch.txt insert end "[gets $idf]\n" others
			}
			close $idf
			pack .tch.txt -expand yes -fill both
      			}
		 }
		 bind $pal.$modnoext <ButtonRelease-3> "destroy .tch"
            }
            incr column
		if {$column == "4"} {set column 0; incr row}
		set curTool $modnoext
	}

	cd $olddir
}


proc killAllPal {} {
	global palId
	for {set i 0} {$i <= $palId} {incr i} {catch {destroy .pal$i}}
	set palId 0
	set curTool none
}


proc linkDelete {c} {
	global modified needbuild
	# you must delete all ports tags (busy, connect*)
#tk_messageBox -message "linkDelete: ::currTags=$::currTags\n ::currTid=$::currTid"
#	set plist [split [lindex [$c gettags current] 0] . ]

##set dmen 0
###if { $plist == ""} { set dmen 1 ; set ::currTid [lindex $::currTags 0]; set plist [lindex $::currTags 0]}

##set dmen 1 
set Tid [lindex $::currTags 0]
##set plist [lindex $::currTags 0] 
set plist [split [lindex $::currTags 0] . ]                                                                                            

	set sport [string range [lindex $plist 0] 4 end ]
	set eport [lindex $plist 1]
#tk_messageBox -message "linkDelete: plist=$plist\n ::currTags=$::currTags\n ::currTid=$::currTid\n Tid=$Tid \n plist=$plist\nsport=$sport   eport=$eport"

	$c dtag $sport busy
	$c dtag $sport connwith.$eport
	$c dtag $eport busy
	$c dtag $eport connwith.$sport

##	if { $dmen == 0} {$c delete current
##	} else { $c delete $Tid }
        $c delete $Tid

	
	set modified 1
	set needbuild 1
#tk_messageBox -message "linkDelete: modified $modified needbuild $needbuild"

}




proc showMathVar {c x y} {
        global wsXsiz wsYsiz
	set myTags [$c gettags current]
	set mylist [lindex $myTags 2].[string range [lindex $myTags 1] 2 end]
	global $mylist
        set xAbs [expr $x + [lindex [$c xview] 0] * $wsXsiz]
        set yAbs [expr $y + [lindex [$c yview] 0] * $wsYsiz]
	set mvlist [join [set $mylist] "\n"]
#tk_messageBox -message "showMathVar: myTags=$myTags=\n mylist=$mylist\n mvlist=$mvlist=\n lindex=[lindex $myTags 1]="
	set tid [$c create text $xAbs $yAbs -text $mvlist -font helpFont -tags {mvitem}]
	set lc [$c bbox $tid] 
	set x1 [expr [lindex $lc 0] - 5]
	set y1 [lindex $lc 1]
	set x2 [expr [lindex $lc 2] + 5]
	set y2 [lindex $lc 3]
	$c create rectangle $x1 $y1 $x2 $y2 -fill white -tags {mvitem}
	$c raise $tid	
}


proc destroyMathVar {c} {
	$c delete mvitem
}





proc buildLegoFiles {c} {
	global env curFileName needbuild
	

	if {$curFileName == "untitled" || $curFileName == "" || $curFileName == "-"} {
		set messaggio "You should first save model topology..."
		tk_messageBox -message $messaggio -type ok
		return 0
	}

	set messaggio "Start F01/F14 building phase now?\n\n"
#	append messaggio "**** Did you remember to save topology? ****"
	if {[tk_messageBox -message $messaggio -type yesno -default yes] == "no"} {return 0}
        
#        topWrite $c save
        if {[topWrite $c save]} {
		return 0
	}


	set LG_MODEL   [file dirname $curFileName]
	set FILE_RNAME [file rootname $curFileName]
      if [file exists ${LG_MODEL}/lg3.sel] {
            file delete -force ${LG_MODEL}/lg3.sel
      }

	set env(LEGO_PATH)    [join [split $env(LG_LEGO)    / ] \\ ]
	set env(LIBUT_PATH)   [join [split $env(LG_LIBUT)   / ] \\ ]
	set env(TOOLS_PATH)   [join [split $env(LG_TOOLS)   / ] \\ ]
	set env(FILESI5_PATH) [join [split $env(LG_FILESI5) / ] \\ ]

	set comm1 [file join $env(LG_LEGO) dolg1lg2.bat]
	set comm2 [join [split $LG_MODEL / ] \\ ]
	set comm3 [join [split $FILE_RNAME / ] \\ ]
	set comm4 ${FILE_RNAME}.out
 
      puts $comm1
      puts $comm2
      puts $comm3
      puts $comm4

	file mkdir [file join $LG_MODEL proc]	
	set chk [catch {exec $comm1 $comm2 $comm3 > $comm4} result]

	if {[file exists [file join $LG_MODEL lg1_done.out]]} {
#		tk_messageBox -message "--->$curFileName"
		autoedi14 
		set mex [tk_messageBox -icon question -type yesno \
 	        -title Message -parent . -message "Files F01 and F14 building \
			correctly done.\n\nEdit F01.DAT?"]
		set needbuild 0
		if {$mex == "yes"} {
		      set file "$comm2\\f01.dat"
#		      set editor $env(LG_LEGO)/edita.bat
		      set editor $env(LG_TEXTEDITOR)
		      catch {exec $editor $file &}
		}
	} else {
		set mex [tk_messageBox -icon question -type yesno \
 	        -title Message -parent . -message "Files F01 and F14 building \
			aborted.\n\nEdit PAG.OUT?"]
		if {$mex == "yes"} {
			set file "$comm2\\pag.out"
        		catch {exec $env(LG_LEGO)/edita.bat $file &}
		}
	}

# fine regolare 
return 1
}


proc buildLegoFiles_linux {c} {
	global env curFileName needbuild


	if {$curFileName == "untitled" || $curFileName == "" || $curFileName == "-"} {
		set messaggio "You should first save model topology..."
		tk_messageBox -message $messaggio -type ok
		return 0
	}

	set messaggio "Start F01/F14 building phase now?\n\n"
#	append messaggio "**** Did you remember to save topology? ****"
	if {[tk_messageBox -message $messaggio -type yesno -default yes] == "no"} {return 0}

        if {[topWrite $c save]} {
		return 0
	}

	set LG_MODEL   [file dirname $curFileName]
	set FILE_RNAME [file rootname $curFileName]
      if [file exists ${LG_MODEL}/lg3.sel] {
            file delete -force ${LG_MODEL}/lg3.sel
      }

	set env(LEGO_PATH)    [join [split $env(LG_LEGO)    / ] \\ ]
	set env(LIBUT_PATH)   [join [split $env(LG_LIBUT)   / ] \\ ]
	set env(TOOLS_PATH)   [join [split $env(LG_TOOLS)   / ] \\ ]
	set env(FILESI5_PATH) [join [split $env(LG_FILESI5) / ] \\ ]

	
      set comm4 ${FILE_RNAME}.out
	if  { $::tcl_platform(os) == "Linux" } {
         set comm1 [file join $env(LEGO_BIN) cad_crealg1 ]
	 set comm2 "c"
	 set comm3 ${FILE_RNAME}
	} else {
	 set comm1 [file join $env(LG_LEGO) dolg1lg2.bat]
	 set comm2 [join [split $LG_MODEL / ] \\ ]
	 set comm3 [join [split $FILE_RNAME / ] \\ ]
	 file mkdir [file join $LG_MODEL proc]
	}
#
#      puts $comm1
#      puts $comm2
#      puts $comm3
#      puts $comm4

#tk_messageBox -message "$comm1-$comm2-$comm3 > $comm4"
# lancio make di costruzione della task
	set lg1_error [catch {exec $comm1 $comm2 $comm3 > $comm4 2>>$comm4} result]
	if { $lg1_error } {
		set mex [tk_messageBox -icon question -type yesno \
			-title Message -parent . -message "Build task Error:\n$comm1 $comm2 $comm3 >> $comm4\nresult:$result\n\nEdit PAG.OUT?"]
			if {$mex == "yes"} {
				set file_pag "${FILE_RNAME}.out"
				set file_lg1a "lg1a.out"
				set editor $env(LG_TEXTEDITOR)
				catch {exec $editor $file_pag $file_lg1a &}
		}
		return 0
	}
	
	if  { $::tcl_platform(os) != "Linux" } {
		autoedi14
	}
	set mex [tk_messageBox -icon question -type yesno \
		-title Message -parent . -message "Files F01 and F14 building correctly done.\n\nEdit F01.DAT?"]
	set needbuild 0
	if {$mex == "yes"} {
		set file "${LG_MODEL}/f01.dat"
#		set editor $env(LG_LEGO)/edita.bat
		set editor $env(LG_TEXTEDITOR)
		catch {exec $editor $file &}
	}
	
# fine regolare di build
	return 1
}







proc include {c} {
   global env curFileName modified modified1 needbuild
   
   catch { destroy .include }
   toplevel .include
   wm title .include "Included model choice"
   frame .include.first
   frame .include.second -relief ridge -bd 1 -height 2
   frame .include.third
   frame .include.fourth -relief ridge -bd 1 -height 2
   frame .include.fifth
   label .include.first.lab -text "Choose model to include ..." -font "Courier 12 bold"
   tixComboBox .include.first.model -editable false
   .include.first.model subwidget entry configure -background white -font "Courier 12 bold"
   set models_list [glob $env(LG_MODELS)/*]
   foreach i $models_list {
       set curr_file [file tail $i]
       if [file isdirectory $i] {
          .include.first.model insert end $curr_file
       }
   }
   label .include.third.lab -text "Include model ..." -font "Courier 12 bold"
   radiobutton .include.third.n -text "...  above current" -variable direction -relief flat -value N
   radiobutton .include.third.s -text "...  below current" -variable direction -relief flat -value S
   radiobutton .include.third.w -text "...  on left  side" -variable direction -relief flat -value W
   radiobutton .include.third.e -text "...  on right side" -variable direction -relief flat -value E
   .include.third.n  select
   button .include.fifth.ok -text OK -command {
      set included [.include.first.model cget -value]
      if { ! [file exists $env(LG_MODELS)/$included/$included.tom] } {
        tk_messageBox -icon warning -title "WARNING" -type ok -parent . \
           -message "File:\n\n      $env(LG_MODELS)/$included/$included.tom\n\n does not exist!\n "
      } else {
         set modified 1
#         set modified1 1
         set needbuild 1
         set pathList [file split $curFileName] 
         set curModel [lindex $pathList [expr [llength $pathList]-2] ]
         set olddir [pwd]
         cd $env(LG_MODELS)/$curModel
         exec $env(LG_TOOLS)/inhoud $curModel $included $direction
         file rename -force inhoud.tom $curModel.tom
         cd $olddir
#         file delete -force  $curModel/proc
         file delete -force $olddir/$curModel.top
         file delete -force $olddir/f01.dat
#tk_messageBox -message "include: eccomi $olddir $curModel"  -type ok -icon warning       
	 if { [topRead $c $curModel]} {return 1}
         set modified 1
#         set modified1 1
         set needbuild 1
#         topWrite $c save
if { $::LINUXPLAT == 0 } {
	 if { ![buildLegoFiles $c]} {return 1}
} else {
	 if { ![buildLegoFiles_linux $c]} {return 1} 
}
         destroy .include
      }
   }
   button .include.fifth.canc -text Cancel -command "destroy .include"
   pack .include.first.lab .include.first.model -side top -pady 1m
   pack .include.third.lab .include.third.n .include.third.s \
        .include.third.w .include.third.e -side top -anchor w -pady 1m
   pack .include.fifth.ok .include.fifth.canc -side left -expand 1 -pady 1m
   pack .include.first .include.second .include.third .include.fourth .include.fifth \
         -side top -fill x -pady 1m -padx 1m 

return 0
}

proc loadHelp {c } {

###   set myTags [$c gettags current]
if {[info vars ::currTid] == ""} {return}
  set myTags [$c gettags $::currTid]
    
#   global progName progNumb
#   set nome [file rootname [lindex $myTags [lsearch $myTags *.name]]]
#   set tid [lindex $myTags 0]   
##   tk_messageBox -message "prima=$myTags\n nome=$nome\n tid=$tid"
#   set x [$c canvasx $x]
#   set y [$c canvasy $y]
#   inputModName $c $x $y  
##   set nuovo_nome "QQ1"
#   $c dtag $nome.name
#   $c addtag $progName.name withtag $tid
#   
#   set myTags [$c gettags $tid]
#   set nome [file rootname [lindex $myTags [lsearch $myTags *.name]]]
#   set tid [lindex $myTags 0]   
#   tk_messageBox -message "dopo=$myTags\n nome=$nome\n tid=$tid"
#
#
   
   set moduleName [string range [lindex $myTags 2] 0 3]
   open_hlp $moduleName
}


proc CambiaNome {c } {
global modified needbuild
global progName  showon enval progNumb mnamedone

if {[info vars ::currTid] == ""} {return}
      	       	
  set myTags [$c gettags $::currTid]

if {[lsearch -exact $myTags  remarkdescr] != -1} { 
# è un remark, non  permetto il cambiamento del nome
      	       	return }
    
   set nome [file rootname [lindex $myTags [lsearch $myTags *.name]]]
##   set tid [lindex $myTags 0]   
#   tk_messageBox -message "prima=$myTags\n nome=$nome\n tid=$tid"
   set x $::currTid_x
   set y $::currTid_y
#   set x [$c canvasx $x]
#   set y [$c canvasy $y]
#####   inputModName $c $x $y  

#	global progName mnamedone enval progNumb
	set mnamedone 0
	set mndlg $c.modname
	catch {destroy $mndlg}
	frame $mndlg -relief raised
#	set enval $progNumb
	set enval $nome
	entry $mndlg.mname -relief sunken -width 4 -font entryFont -textvariable enval
	label $mndlg.askl -text "insert name (4 char)"
	pack $mndlg.askl  -side top -fill x
	pack $mndlg.mname -side top
	button $mndlg.accept -text OK -command "set mnamedone 1"
	button $mndlg.dismiss -text Quit -command "set mnamedone 2"
	pack $mndlg.accept $mndlg.dismiss -side left
	pack $mndlg.dismiss -side right
	set wid [$c create window $x $y -window $mndlg]
	focus $mndlg.mname
	$mndlg.mname selection range 0 3
	bind $mndlg.mname <Return> "set mnamedone 1"

#	grab $mndlg
#bell
#---nuovo
	if {[string length $enval] > 4} {set enval [string range $enval 0 3]}
	if {[string length $enval] < 4} {set enval [string range ${enval}____ 0 3]}
	set progName [string toupper $enval]
#	while {[$c find withtag $progName.name] != {}} {
#		set progName [string range ${progNumb}____ 0 3]
#		incr progNumb
#		set enval $progNumb
#		if {[string length $enval] > 4} {set enval [string range $enval 0 3]}
#		if {[string length $enval] < 4} {set enval [string range ${enval}____ 0 3]}
#		set progName [string toupper $enval]
#	}

        set ok1 1
	while { $ok1 } {
	vwait mnamedone
	   if {$mnamedone == 2} {
	   	set ok1 0
	   	grab release $mndlg
	   	$c delete $wid
	   } else {
	   if {[string length $enval] > 4} {set enval [string range $enval 0 3]}
	   if {[string length $enval] < 4} {set enval [string range ${enval}____ 0 3]}
	   set progName [string toupper $enval]
	   if { [$c find withtag $progName.name] != {} && $progName != $nome } {
		tk_messageBox -icon info -message "Name already assigned!" -type ok
		set enval $progNumb
	   } else {
	   set ok1 0
	   grab release $mndlg
	   $c delete $wid
	   aggiungi_eccedi14 $nome $progName 
	   }
	  }
	}
	
#--- fine  nuovo







#   set nuovo_nome ...
	   if {$mnamedone == 1} {
   $c dtag $nome.name
   $c addtag $progName.name withtag $::currTid
   set needbuild 1
   set modified 1  
#   set myTags [$c gettags $tid]
#   set nome [file rootname [lindex $myTags [lsearch $myTags *.name]]]
#   set tid [lindex $myTags 0]   
##   tk_messageBox -message "dopo=$myTags\n nome=$nome\n tid=$tid"
	catch { ShowNames $c 1 }
	if { $showon == 2 } {
       		catch { ShowNames $c 2 }
	}
	if { $showon == 3 } {
       		catch { ShowNames $c 3 }
	}
}
catch {unset  ::currTags};catch {unset  ::currTid}; catch {unset  ::currTid_x}; catch {unset  ::currTid_y}

}



proc esiste_processo { prid } {

# ritorna 1 se esiste il processo con il process id "prid"

switch $::LINUXPLAT {
			0 { 
				set compslist "pslist" 
				catch { exec $compslist $prid | grep -c "was not found"} esito
### tk_messageBox -message "esiste_processo: $esito"  -type ok -icon warning
				if { [ lindex $esito 0 ] == "0"  } { 
				return 1 
				} else { 
	   				return 0 
					}			
			
			}
			1 {    
			
			
			return 1
			}


		}
}


proc WarnYou { flag } {
       global modified needbuild modified1
       global lgsincropid
       set mex "X"

#      tk_messageBox -message $lgsincropid  -type ok -icon warning               


        if { $lgsincropid != -1 } {
          if { [ esiste_processo $lgsincropid ] == 1  } {
       
		set mex [tk_messageBox -icon question -type yesno \
         		-title Question -parent . -message "LgSincro running... Do you want to kill it?" ]
		if {$mex == "yes"} {	
		      set command2 "pskill" 
                      catch { exec $command2 $lgsincropid } 
                      catch { exec $command2 "lgser" } 
                      catch { exec $command2 "sincview"} }
           } 
	 
         }
 
        
       if {  $modified == 1 || $modified1 == 1  } {
     	  set mex [tk_messageBox -icon warning -type yesno \
              -title Warning -parent . -message "Do you want to quit without saving?"]
     	  if {$mex == "yes"} {
     		if {$flag == "exit"} {
     			killAllPal; exit 0	
     		} else {
     			killAllPal; exit 0
     		}
     	  } 
       } 
      
       if { $needbuild == 1} {
#             tk_messageBox -icon info -message "Build F01/F14 is needed!" -type ok
        set res [tk_dialog .panic "Panic!" "Build F01/F14 is needed!" \
             question 0 "OK" "Exit Anyway"   ]
        switch $res {
          0 
            { } 
          1 
            { exit } 
         }
              
       } else { 
     	  if {$flag == "exit"} {
      		   if {$mex != "no"} {killAllPal; exit 0}	
     	   } else {
     		   killAllPal; exit 0
     	   }
       }  
        

#tk_messageBox -icon warning -message "warn3" -type ok

}


#proc RunSample {w } {
#
#
#
#    #----------------------------------------
#    # Create the first page
#    #----------------------------------------
#    set f [$w.nb subwidget hard_disk]
#
#    # Create two frames: one for the common buttons, one for the
#    # other widgets
#    #
#    frame $f.f
#    frame $f.common
#    pack $f.f      -side left  -padx 2 -pady 2 -fill both -expand yes
#    pack $f.common -side right -padx 2 -pady 2 -fill y
#
#    # Create the controls that only belong to this page
#    #
#    tixControl $f.f.a -value 12   -label "Access Time: "
#    tixControl $f.f.w -value 400  -label "Write Throughput: "
#    tixControl $f.f.r -value 400  -label "Read Throughput: "
#    tixControl $f.f.c -value 1021 -label "Capacity: "
#    pack $f.f.a $f.f.w $f.f.r $f.f.c  -side top -padx 20 -pady 2
#
#    # Create the common buttons
#    #
#    CreateCommonButtons $w $f.common
#    
#    #----------------------------------------
#    # Create the second page	
#    #----------------------------------------
#    set f [$w.nb subwidget network]
#
#    frame $f.f
#    frame $f.common
#    pack $f.f      -side left  -padx 2 -pady 2 -fill both -expand yes
#    pack $f.common -side right -padx 2 -pady 2 -fill y
#
#    tixControl $f.f.a -value 12   -label "Access Time: "
#    tixControl $f.f.w -value 400  -label "Write Throughput: "
#    tixControl $f.f.r -value 400  -label "Read Throughput: "
#    tixControl $f.f.c -value 1021 -label "Capacity: "
#    tixControl $f.f.u -value 10   -label "Users: "
#
#    pack $f.f.a $f.f.w $f.f.r $f.f.c $f.f.u -side top -padx 20 -pady 2
#
#    CreateCommonButtons $w $f.common
#}


proc checkf14 { c2 } {
	global f14File f14time
        file stat $f14File statis
        if { $statis(atime) != $f14time } {
#        	puts "checkf14: f14time=$f14time  statis(atime)=$statis(atime)"; 
        	loadF01 $c2 no 
        	file stat $f14File statis
        	}
  	set f14time $statis(atime)
	return 0
}

proc modifica_remark {c} {	
	global demo

set x $::currTid_x
set y $::currTid_y


        set ignora 0
	set mylist [$c gettags $::currTid]
#se non è una remark esco
        if {[lsearch -exact $mylist  remarkdescr] == -1} { return }
#è un remark, procedo	
	set mytag [lindex $mylist [lsearch $mylist id* ]]
	set fontbuff [leggi_font $c $mytag 1 "qq"]

        set buff_f [lindex $fontbuff 0]
        set buff_siz [lindex $fontbuff 1]
        set buff_color [lindex $fontbuff 2]
        if {$buff_color == ""} {set buff_color black}
set ::xfont "$buff_f $buff_siz"
set ::retcolor $buff_color
	set demo(welfont_index) [ lsearch $::listafont $buff_f]
        set demo(welsize_index) [ lsearch $::listafontsize $buff_siz]

# debug  tk_messageBox -message "doppio 1: fontbuff=$fontbuff\n buff_f=$buff_f \n $::listafont\n $demo(welfont_index)"
# debug tk_messageBox -message "doppio 2: fontbuff=$fontbuff\n buff_siz=$buff_siz \n $::listafontsize\n $demo(welsize_index) "

	set testo "nuovo testo"
        set vecchio_testo [$c itemcget $mytag -text ]
        
# 	set lc [$c bbox $mytag] 
# 	set xx [lindex $lc 2]
# 	set yy [lindex $lc 1]
#
	set mndlg $c.testo_edit
	catch {destroy $mndlg}
	frame $mndlg -relief raised
	
	set mndlg_testo  $mndlg.testo
  frame $mndlg_testo
  
  set mndlg_testo_y $mndlg_testo.y
  set mndlg_testo_t $mndlg_testo.t
  
   scrollbar $mndlg_testo_y -command "$mndlg_testo_t yview"
   text $mndlg_testo_t -font $buff_f -fg $buff_color -wrap word -yscrollc "$mndlg_testo_y set"  -width 30 -height 3      
   
   set mndlg_but $mndlg.but
   frame $mndlg_but
   button $mndlg_but.save -text " OK " -command "set mfontdone 1"
   button $mndlg_but.quit -text Quit -command " set ignora 1; set mfontdone 1 "
    set mndlg_font $mndlg.font
    frame $mndlg_font

### controlli per il font
    tixComboBox $mndlg_font.cbx1 -command "MainTextFont $mndlg $mndlg_testo_t" \
	-options {
	    entry.width    15
	    listbox.height 3
	}
    tixComboBox $mndlg_font.cbx2 -command "MainTextFont $mndlg $mndlg_testo_t" \
	-options {
	    entry.width 4
	    listbox.height 3
	}

    set demo(welfont) $mndlg_font.cbx1
    set demo(welsize) $mndlg_font.cbx2
        
     $mndlg_font.cbx1 insert end [lindex $::listafont 0]     
     $mndlg_font.cbx1 insert end [lindex $::listafont 1]
     $mndlg_font.cbx1 insert end [lindex $::listafont 2]
     $mndlg_font.cbx1 insert end [lindex $::listafont 3]
     $mndlg_font.cbx1 insert end [lindex $::listafont 4]
     $mndlg_font.cbx1 insert end [lindex $::listafont 5]
 
     $mndlg_font.cbx2 insert end [lindex $::listafontsize 0]
     $mndlg_font.cbx2 insert end [lindex $::listafontsize 1]
     $mndlg_font.cbx2 insert end [lindex $::listafontsize 2]
     $mndlg_font.cbx2 insert end [lindex $::listafontsize 3]
     $mndlg_font.cbx2 insert end [lindex $::listafontsize 4]
     $mndlg_font.cbx2 insert end [lindex $::listafontsize 5]
     $mndlg_font.cbx2 insert end [lindex $::listafontsize 6]
     $mndlg_font.cbx2 insert end [lindex $::listafontsize 7]
     $mndlg_font.cbx2 insert end [lindex $::listafontsize 8]

#    $mndlg_font.cbx1 insert end "Courier"
#    $mndlg_font.cbx1 insert end "Helvetica"
#    $mndlg_font.cbx1 insert end "Lucida"
#    $mndlg_font.cbx1 insert end "Times Roman"
#
#    $mndlg_font.cbx2 insert end 8
#    $mndlg_font.cbx2 insert end 10
#    $mndlg_font.cbx2 insert end 12
#    $mndlg_font.cbx2 insert end 14
#    $mndlg_font.cbx2 insert end 18
#debug tk_messageBox -message "1 doppio click! fontbuff=$fontbuff ::xfont=$::xfont" -type ok

    $mndlg_font.cbx2 pick $demo(welsize_index)
    $mndlg_font.cbx1 pick $demo(welfont_index)

# bottone colori
set ::mndlg_font_color $mndlg_font.color
#	button $mndlg_font_color -text Color -command "set ::retcolor [tk_chooseColor]; $mndlg_testo_t configure  -font $::xfont -fg $::retcolor"
	button $::mndlg_font_color -text Color -command {set ::retcolor [tk_chooseColor]; if {$::retcolor != ""} {$::mndlg_font_color configure  -background $::retcolor}}



    # Pack the comboboxes together
    #
#    pack $mndlg_font.cbx1 -side right -padx 4 -pady 4
  pack $mndlg_font -fill x
  pack $mndlg_font.cbx1 -side left 
  pack $mndlg_font.cbx2 -side left 
  pack $mndlg_font.color -side right 


	pack $mndlg_testo_y  -side right -fill y

	pack $mndlg_testo_t  -expand yes -fill both -anchor w       
pack $mndlg_testo -fill x
#	pack [text $mndlg.t -wrap word -yscrollc "$mndlg.y set"  -width 30 -height 3] -side left -fill both -expand 1       

#	

pack $mndlg_but.save -side left -padx 5m 
pack $mndlg_but.quit -side left
pack $mndlg_but -side bottom 
	
#grid $mndlg -in $c -row 0 -column 0 -rowspan 1 -columnspan 1 -sticky news
#grid $mndlg.y -row 0 -column 1 -rowspan 1 -columnspan 1 -sticky news
## grid $f.hscroll -row 1 -column 0 -rowspan 1 -columnspan 1 -sticky news
#grid rowconfig $f 0 -weight 1 -minsize 0
#grid columnconfig $f 0 -weight 1 -minsize 0
#	
	
   $mndlg_testo.t insert end $vecchio_testo
#	set wid [$c create window $xx $yy -window $mndlg]
	set wid [$c create window $x $y -window $mndlg]
	focus $mndlg

	vwait mfontdone
        if { $ignora == 0 } {         	

	set testo [$mndlg_testo.t get 1.0 "end - 1 c"]
	if { [regexp {[[:alpha:]]} $testo] == 0 } { set testo "___" }
# debug tk_messageBox -message "doppio click! mylist=$mylist=\nmytag=$mytag=\n =>$c\n =>$vecchio_testo\n testo=$testo\n font $::xfont" -type ok
	if {$::retcolor == ""} {set ::retcolor black}
	$c itemconfigure $mytag -text $testo -font $::xfont -fill $::retcolor
        
# esempio con font diverso	$c itemconfigure $mytag -text $testo -font {Times 16}

#salvo il nuovo font nella memoria della canvas...
set xfont_color "$::xfont $::retcolor"
        leggi_font $c $mytag 2 $xfont_color 
	$c raise $mytag
	set ::modified 1
        }
	grab release $mndlg
	$c delete $wid
#set retcolor [tk_chooseColor]
}


proc createcanva { f } {

global env demo
global wsBackg wsWidth wsHeight wsScrWidth 
global wsScrHeight wsXsiz wsYsiz wsXmin wsYmin 
global helpPath
global modified needbuild
#tk_messageBox -message $f -type ok
set c $f.canTOP

#set wsBackg gray90
set wsBackg azure2
set wsWidth 512
set wsHeight 384
set wsScrWidth 800
set wsScrHeight 600
set wsXsiz $wsScrWidth
set wsYsiz $wsScrHeight
set wsXmin $wsWidth
set wsYmin $wsHeight

canvas $c -bg $wsBackg -scrollregion [list 0 0 $wsScrWidth $wsScrHeight] \
	-width $wsWidth -height $wsHeight -xscrollcommand "$f.hscroll set" \
	-yscrollcommand "$f.vscroll set"
scrollbar $f.vscroll -command "$c yview"
scrollbar $f.hscroll -orient horiz -command "$c xview"

grid $c -in $f -row 0 -column 0 -rowspan 1 -columnspan 1 -sticky news
grid $f.vscroll -row 0 -column 1 -rowspan 1 -columnspan 1 -sticky news
grid $f.hscroll -row 1 -column 0 -rowspan 1 -columnspan 1 -sticky news
grid rowconfig $f 0 -weight 1 -minsize 0
grid columnconfig $f 0 -weight 1 -minsize 0

#images
set pixmapPath "$env(LG_PIXMAPS)"
set olddir [pwd]
cd $pixmapPath
foreach singleconn [glob -nocomplain {????_[news].ppm}] {
	image create photo [file rootname $singleconn] \
		-file [file join $pixmapPath $singleconn]
}
image create photo portActive -file [file join $pixmapPath actconn.ppm]
cd $olddir

#help files
set helpPath "$env(LG_HELP)"
#catch {font create helpFont -family Helvetica -size 9}
#catch {font create entryFont -family Courier -size 9}
#catch {font create titleFont -family Helvetica -size 12 -weight bold}

catch {font create helpFont -family Helvetica -size 9}
  if  { $::tcl_platform(os) == "Linux" } {
	catch {font create entryFont -family Courier -size 12}
        catch {font create titleFont -family Courier -size 12 -weight bold -slant italic}

  } else {
	catch {font create entryFont -family Courier -size 9}
        catch {font create titleFont -family Courier -size 9 -weight bold -slant italic}
  }
catch {font create entryBig -family Courier -size 14}
catch {font create titleBig -family Courier -size 14 -weight bold}

#
# DEFINIZIONE TASTI
#
####$c bind module <1> "itemStartDrag $c %x %y"
####$c bind module <B1-Motion> "itemDrag $c %x %y"
set ::inib_sel 0
set ::mult_sel 0
$c bind module <1> {set ::inib_sel 1
#debug	         puts bind_module_1_inib_sel$::inib_sel
#
#if { $::mult_sel == 1 } {itemStartDrag_mult $c %x %y
#} else {itemStartDrag $c %x %y}

itemStartDrag $c %x %y
        	          
	          }

$c bind module <Shift-Button-1> {
	         set ::inib_sel 1
#debug 	   puts "bind_Shift-Button-1 inib_sel= $::inib_sel"
                 set ::mult_sel 1
                 itemStartDrag $c %x %y 	          
	          }


$c bind module <B1-Motion> {
#debug	puts module-B1-Motion_inib_sel$::inib_sel
	if { $::inib_sel == 1 } {itemDrag_mult $c %x %y}
	}


$c bind module <B1-ButtonRelease> { 
#debug	puts "bind_module:B1-ButtonRelease"
	itemFinishDrag $c %x %y; set ::inib_sel 0
	}
###$c bind module <3> "loadHelp $c %x %y"

$c bind module <3> { 
	             set ::currTags [$c gettags current];
#	             tk_messageBox -message $::currTags
                     set ::currTid [lindex $::currTags 0]
# lo faccio gia in $c bind <3> ...
#                     set ::currTid_x [$c canvasx %x]
#                     set ::currTid_y [$c canvasy %y]
                    }
$c bind connection <3> { 
	             set ::currTags [$c gettags current];
#	             tk_messageBox -message $::currTags
                     set ::currTid [lindex $::currTags 0]
# lo faccio gia in $c bind <3> ...
#                     set ::currTid_x [$c canvasx %x]
#                     set ::currTid_y [$c canvasy %y]
                    }

# $c bind module <Any-Enter> "itemEnter $c"


#tolgo il comando da tastiera di rotazione del modulo 
#####$c bind module <Shift-Button-3> "itemRotate $c"
#tolgo il comando da tastiera di delete del modulo 
#####$c bind module <Shift-Button-1> "itemDelete $c"

$c bind port <1> "portSelect $c"
if { $::LINUXNOMATLAB != 1 } {
# se PC
  $c bind port <Alt-ButtonPress-3> "showMathVar $c %x %y"
} else {
# se linux
  $c bind port <Shift-Alt-ButtonPress-3> "showMathVar $c %x %y"
}
bind $c <Alt-ButtonRelease-3> "destroyMathVar $c"

# tolgo il comando da tastiera di delete della connessione
#### $c bind connection <Shift-Button-1> "linkDelete $c"

bind $c <Control-Button-1> "itemAdd $c %x %y"

set demo(welsize_index) 3
set demo(welfont_index) 1
set ::listafont      [list "arial" "batang" "courier" "helvetica" "lucida" "times" ]
set ::listafontsize  [list 8 10 12 14 18 22 26 30 60]
#set ::xb1 0
#set ::yb1 0

## $c bind module <Double-ButtonPress-1> { modifica_remark $c %x %y }
           
bind $c <Alt-ButtonPress-2> {tk_messageBox -message "<Alt-ButtonPress-2>\n[$c gettags current]\n posizione: [$c coords current]"}              

#bind $c <Alt-ButtonPress-1> {
##esperimenti sul search....
#      set nome HF51
#      trova_item $c $nome
#
#}

#stripped-down initialization

#
#bind $c <1> "delete_sel $c"
#
#bind $c <Alt-ButtonPress-1> {catch {$c dtag selezionato};catch {unset ::select_list}; set ::xb1 [$c canvasx %x];set ::yb1 [$c canvasy %y]
##debug tk_messageBox -message "Alt-Button: x=%x y=%y\n canvasx=[$c canvasx %x] canvasy=[$c canvasy %y]\n xview=[$c xview] yview=[$c yview]"
#}
#<B1-ButtonPress>
#
set ::start_sel 0
bind $c <1> {
#	puts "B1-ButtonPress"
if { $::inib_sel == 0} {
	set ::start_sel 1
#debug	puts "B1-ButtonPress e inib_sel 0"
        set ::mult_sel 0
	delete_sel $c
	set ::xb1 [$c canvasx %x]
	set ::yb1 [$c canvasy %y]
#debug tk_messageBox -message "Alt-Button: x=%x y=%y\n canvasx=[$c canvasx %x] canvasy=[$c canvasy %y]\n xview=[$c xview] yview=[$c yview]"
 }
}

bind $c <B1-Motion> { 
#		puts "B1-Motion"
	      if { $::start_sel == 1} {
	      	catch {$c delete seledrag}
	      	set rect [$c create rectangle $::xb1 $::yb1 [$c canvasx %x] [$c canvasy %y] -tags {seledrag}]
	                      update}
	      }


bind $c <B1-ButtonRelease> {
#debug	puts "B1-ButtonRelease: cisono=$::cisono" 
	if { $::start_sel == 1} {

#debug	puts "B1-ButtonRelease: dentro else --- cisono=$::cisono" 

	   set ::xb2 [$c canvasx %x];set ::yb2 [$c canvasy %y]
	   $c addtag selezionato overlapping $::xb1 $::yb1 $::xb2 $::yb2
	   set selle [$c find withtag selezionato]
	   set moduli [$c find withtag module]
           set ::cisono 0 	                            
           foreach tid $moduli {
           set risul -1
           catch {set risul [lsearch -exact $selle $tid]}
           if { $risul != -1} { lappend ::select_list $tid; set ::cisono 1;
             #tk_messageBox -message "Alt-Button: tid=$tid\n selezionato=$selle\n moduli=$moduli\n select_list=$::select_list\n cisono=$cisono"
             set ::mult_sel 1
             }
           }
           
           catch [$c delete seledrag]
           if {$::cisono != 0 } {itemStartDrag_mult_all $c 0}
        set ::start_sel 0
        }
#debug	puts "B1-ButtonRelease: uscita --- cisono=$::cisono" 

}


#---menu con tk 
    set pop $c.pop
    menu $pop  -activebackground darkblue -activeforeground white -tearoff 0   

    $pop add command -label "Select All" -under 0 -command  {set ::mult_sel 1; itemStartDrag_mult_all $c 1} 
#    $pop add command -label "Copy" -under 0 -command {set ::currTidCopy $::currTid; set ::currTagsCopy $::currTags}
    $pop add command -label "Copy" -under 0 -command {
    	if {$::mult_sel == 0} then {set ::currTidCopy $::currTid}  else {
    		set ::currTidCopy $::select_list; 
#    		tk_messageBox -message "Copy 1: ::currTidCopy=$::currTidCopy"
    		}
    	}
    $pop add command -label "Paste" -under 0 -command "IncollaItem $c"                                    
    $pop add command -label "Help" -under 0 -command "loadHelp $c"
    $pop add command -label "Add Text" -under 0 -command "AddRemark $c"
    $pop add command -label "Modify Text" -under 0 -command "modifica_remark $c"
    $pop add command -label "Rename" -under 0 -command "CambiaNome $c"
    $pop add command -label "Rotate module" -under 0 -command "itemRotate $c"
    $pop add command -label "Delete" -under 0 -command "itemDelete_new $c"

#    set dove [$wlist subwidget listbox ]         { modifica_remark $c %x %y }

    bind $c <ButtonRelease-3> "tk_popup $pop %X %Y"
    
    bind $c  <3> { 
                     set ::currTid_x [$c canvasx %x]
                     set ::currTid_y [$c canvasy %y]
#tk_messageBox -message "bind_3: [$c gettags current]"
	             set ::currTags [$c gettags current];
#	             tk_messageBox -message $::currTags
                     set ::currTid [lindex $::currTags 0]
                     set pop $c.pop
                     if {[lsearch [$c gettags $::currTid] link*] != -1} then {
# è un link              
                     itemStartDrag $c $::currTid_x $::currTid_y 
                     $pop entryconfigure 1 -state disabled 	
                     $pop entryconfigure 2 -state disabled 	
                     $pop entryconfigure 3 -state disabled 	
                     $pop entryconfigure 4 -state disabled 	
                     $pop entryconfigure 5 -state disabled 	
                     $pop entryconfigure 6 -state disabled 	
                     $pop entryconfigure 7 -state disabled 	
                     $pop entryconfigure 8 -state normal -label "Delete link"
                    } elseif { $::currTid == ""} then { 
# è lo sfondo
                     $pop entryconfigure 1 -state disabled 	
                     if {[info exists ::currTidCopy] == 1} then {$pop entryconfigure 2 -state normal
                          } else {$pop entryconfigure 2 -state disabled} 	
                     $pop entryconfigure 3 -state disabled 	
                     $pop entryconfigure 4 -state normal 	
                     $pop entryconfigure 5 -state disabled 	
                     $pop entryconfigure 6 -state disabled 	
                     $pop entryconfigure 7 -state disabled
                     $pop entryconfigure 8 -state disabled -label "Delete"
                    } elseif {[lsearch -exact $::currTags  remarkdescr] != -1} then { 
# è un testo
                     itemStartDrag $c $::currTid_x $::currTid_y
                     $pop entryconfigure 1 -state normal 	
                     $pop entryconfigure 2 -state disabled 	
                     $pop entryconfigure 3 -state disabled 	
                     $pop entryconfigure 4 -state disabled 	
                     $pop entryconfigure 5 -state normal 	
                     $pop entryconfigure 6 -state disabled 	
                     $pop entryconfigure 7 -state disabled
                     $pop entryconfigure 8 -state normal -label "Delete"
                     
                   } elseif {[lsearch -exact $::currTags  module] != -1} then { 
# è un modulo                	
                     itemStartDrag $c $::currTid_x $::currTid_y
                     $pop entryconfigure 1 -state normal 	
                     $pop entryconfigure 2 -state disabled 	
                     $pop entryconfigure 3 -state normal 	
                     $pop entryconfigure 4 -state disabled 	
                     if {$::mult_sel == 0} then {
                        $pop entryconfigure 3 -state normal 	
                        $pop entryconfigure 4 -state disabled 	
                        $pop entryconfigure 5 -state disabled 	
                     	$pop entryconfigure 6 -state normal
                     	$pop entryconfigure 7 -state normal
                     	} else {
                        $pop entryconfigure 3 -state disabled 	
                        $pop entryconfigure 4 -state disabled 	
                        $pop entryconfigure 5 -state disabled 	
                     		$pop entryconfigure 6 -state disabled	
                     		$pop entryconfigure 7 -state disabled	
                      }
                     $pop entryconfigure 8 -state normal -label "Delete"
                                     	
                } else {
# è una porta o qulcos'altro
                     $pop entryconfigure 1 -state disabled 	
                     $pop entryconfigure 2 -state normal 	
                     $pop entryconfigure 3 -state disabled 	
                     $pop entryconfigure 4 -state normal 	
                     $pop entryconfigure 5 -state disabled 	
                     $pop entryconfigure 6 -state disabled 	
                     $pop entryconfigure 7 -state disabled
                     $pop entryconfigure 8 -state disabled -label "Delete"
                 	
                	}        	

                 }

return $c

}

proc itemDelete_new {c} {
	
puts "itemDelete_new: ::currTags=$::currTags\n ::currTid=$::currTid\n ::select_list=$::select_list"
#tk_messageBox -message "itemDelete_new: ::currTags=$::currTags\n ::currTid=$::currTid\n ::select_list=$::select_list"
#####funziona ma commento momentanemente  


foreach ::currTid $::select_list {
if {[lsearch [$c gettags $::currTid] link*] != -1} {
       linkDelete $c
#			tk_messageBox  -message "itemDelete_new: è un link $::currTid" -type ok
} else {
	itemDelete $c
	}
####
}


#foreach ::currTid $::select_list {
#if {[lsearch [$c gettags $::currTid] link*] != -1} {
#       linkDelete $c
#			tk_messageBox  -message "itemDelete_new: è un link $::currTid" -type ok
#}
#}

#foreach ::currTid $::select_list {
#if {[lsearch [$c gettags $::currTid] link*] == -1} {
#	itemDelete $c
#	}
#}
#
#}
#

proc IncollaItem {c} {
	
global progNumb needbuild modified   


# tolgo da currtidcopy le tag dei rettagoli di selezione
#set tidcopy ""

catch {unset  tidcopy}
foreach tid $::currTidCopy {
		if { [regexp id $tid] != 0 } { lappend tidcopy $tid}

}

#lappend tidcopy [lindex $tid [lsearch -regexp $tid id]]
#debug   tk_messageBox -message "IncollaItem 00:tidcopy=$tidcopy"
#set qq [puts $::tidcopy]
#set lc [$c bbox $::tidcopy ]
#set lc [$c bbox id1 id5 id8 id14 id24]

#set lc [$c bbox [lindex $::currTidCopy [lsearch -regexp $::currTidCopy id*]]]

#tk_messageBox -message "IncollaItem: lc=$lc\n currTidCopy=$::currTidCopy\n tidcopy=$::tidcopy"

#set delta_x [expr $::currTid_x - [lindex $lc 0]]
#set delta_y [expr $::currTid_y - [lindex $lc 1]]



catch {unset  tidpaste}
set xmin 10000.0
set ymin 10000.0
foreach mytid  $tidcopy 	{
  set x [lindex [$c coords  $mytid] 0]
  set y [lindex [$c coords  $mytid] 1]
	if {[expr $x < $xmin] == 1} {set xmin $x}
	if {[expr $y < $ymin]== 1} {set ymin $y}
}

set delta_x [expr $::currTid_x - $xmin]
set delta_y [expr $::currTid_y - $ymin]
#debug tk_messageBox -message "IncollaItem: xmin=$xmin\n ymin=$ymin"
foreach mytid  $tidcopy 	{
	set mytags [$c gettags $mytid]
set curname [file rootname [lindex [$c gettags $mytid] [lsearch [$c gettags $mytid] *.name]]]	
	
#debug 	tk_messageBox -message "IncollaItem 0: $mytid\n mytags=$mytags\n curname=$curname"	
#  if  {[lsearch -exact $mytags  selectitem] != -1} {continue}
	
	if {[lsearch -exact $mytags  remarkdescr] != -1} { set isremark 1; set lpath [file rootname [lindex $mytags 5]]
	} else {set isremark 0; set lpath [file rootname [lindex $mytags 4]]}
	
	set ctool [file rootname [lindex $mytags 2]]
	set ori [file rootname [lindex $mytags 3]]
	
	#set x [expr $::currTid_x+2]
	#set y [expr $::currTid_y+2]
	
	set x [expr [lindex [$c coords  $mytid] 0] + $delta_x]
	set y [expr [lindex [$c coords  $mytid] 1] + $delta_y]
	
	
	
	
	set enval $progNumb
	if {[string length $enval] > 4} {set enval [string range $enval 0 3]}
	if {[string length $enval] < 4} {set enval [string range ${enval}____ 0 3]}
	set prnum [string toupper $enval]
#debug tk_messageBox -message "IncollaItem 1: $::currTags\n lpath=$lpath ctool=$ctool ori=$ori\n progNumb=$progNumb\n prnum=$prnum"
	lappend prnum_list $prnum
	set mymod_paste [itemAddFromfile $c $x $y $ctool $lpath $prnum $ori $curname]
#tk_messageBox -message "IncollaItem 2: $::currTags\n lpath=$lpath ctool=$ctool ori=$ori\n progNumb=$progNumb\n prnum=$prnum curname=$curname"
	
	if {$isremark == 1} {
		set testo_attuale [$c itemcget $mytid -text ]
		set xfont_color [leggi_font $c $mytid 1 "qq"]
		set xfont "[lindex $xfont_color 0] [lindex $xfont_color 1]"
		set colore [lindex $xfont_color 2]
#debug tk_messageBox -message "IncollaItem: testo_attuale=$testo_attuale\n xfont_color=$xfont_color\n xfont=$xfont colore=$colore"
#salvo lre impostzioni di font e colore per il nuovo oggetto nella memoria della canvas...
                leggi_font $c $mymod_paste 2 $xfont_color 
                $c itemconfigure $mymod_paste -text $testo_attuale -font $xfont -fill $colore
         }
   set needbuild 1
   set modified 1  
         		
lappend tidpaste $mymod_paste
 }	
#debug tk_messageBox -message "IncollaItem: mymod_list=$mymod_list"
	delete_sel $c
	set ::select_list $tidpaste
	itemStartDrag_mult_all $c 0

incollaitem_connetti $c $tidcopy $tidpaste


}

proc aggiungi_eccedi14 { sorgname destname } {
 if [ file exists edi14_eccezioni_letto.out ] {
 file delete -force edi14_eccezioni.inp
 file delete -force edi14_eccezioni_letto.out
 }
 
 set f [checkopen edi14_eccezioni.inp a+]
       puts $f "$sorgname,$destname"
       close $f

}



proc incollaitem_connetti {c tidcopy tidpaste} {
#debug tk_messageBox -message "incollaitem_connetti: tidcopy=$tidcopy   tidpaste=$tidpaste"	
	
	foreach myid $tidcopy myid_paste $tidpaste {
		foreach port [$c find withtag $myid] {
			if {[lsearch [$c gettags $port] module] != "-1"} {continue} 

			set port1 [lindex [$c gettags $port] [lsearch [$c gettags $port] port?*]]

#debug tk_messageBox -message "incollaitem_connetti: myid=$myid - myid_paste=$myid_paste\n port=$port \n port1=$port1"
				if {[lsearch [$c gettags $port] busy] != "-1"} {
			

					set cptag [lindex [split [lindex [$c gettags $port] [lsearch [$c gettags $port] connwith.*]] . ] end ]

#debug tk_messageBox -message "incollaitem_connetti: $port busy=[$c gettags $port]\n cptag=$cptag	"											
					set port2 [lindex [$c gettags $cptag] [lsearch [$c gettags $cptag] port?*]]

					foreach modorport [$c find withtag [lindex [$c gettags $cptag] 1]] {
#tk_messageBox -message "incollaitem_connetti: modorport=$modorport"
						if {[lsearch -exact [$c gettags $modorport] module] != "-1"} {
							set cpmod [file rootname [lindex [$c gettags $modorport] [lsearch [$c gettags $modorport] *.name]]]
set pastemod_to ""
set id_pastemod_to [lindex $tidpaste [lsearch $tidcopy id$modorport]]
set pastemod_to [file rootname [lindex [$c gettags $id_pastemod_to] [lsearch [$c gettags $id_pastemod_to] *.name]]]
#debug tk_messageBox -message "incollaitem_connetti: Trovato --- modorport=$modorport\n cpmod=$cpmod\n id_pastemod_to=$id_pastemod_to pastemod_to=$pastemod_to"
						}
					}

set pastemod_from ""
set cpmod_from [file rootname [lindex [$c gettags $myid] [lsearch [$c gettags $myid] *.name]]]
set pastemod_from [file rootname [lindex [$c gettags $myid_paste] [lsearch [$c gettags $myid] *.name]]]
#debug tk_messageBox -message "incollaitem_connetti: 2 myid=$myid  cpmod_from=$cpmod_from  port=$port\n connesso con\n  cpmod=$cpmod (cptag=$cptag)\n  port1=$port1  port2=$port2\n pastemod_from=$pastemod_from pastemod_to=$pastemod_to"
#					puts $fileid "$t1 $phcNum $t2 $cpmod"
				
if { $pastemod_to != "" && $pastemod_to != "" } {ffconnect $c $pastemod_from   $port1  $pastemod_to  $port2}				
				} 
				
# fine secondo foreach	sulla porta	   
		   } 

#fine primo foreach
	} 

}

proc AddRemark {c} {
	
global progNumb env
set lpath $env(LG_LIBRARIES)/remark
set ctool "@com_0"
set ori n

set x $::currTid_x
set y $::currTid_y



set enval $progNumb
if {[string length $enval] > 4} {set enval [string range $enval 0 3]}
if {[string length $enval] < 4} {set enval [string range ${enval}____ 0 3]}
set prnum [string toupper $enval]
#tk_messageBox -message "IncollaItem: $::currTags\n lpath=$lpath ctool=$ctool ori=$ori\n progNumb=$progNumb\n prnum=$prnum"

set curname "?"
itemAddFromfile $c $x $y $ctool $lpath $prnum $ori $curname

}

proc agg_vis_noti { } {
	global nn numeVblo numeNoto curFileName nn2
#tk_messageBox -message "qq" -type ok	
	if {$curFileName == "untitled" || $curFileName == ""} {
		return
	}
	
$nn.vimp  configure -text [expr $numeNoto(UA)+$numeNoto(US)+$numeNoto(IN)]  -background grey80
$nn.vrich  configure -text [expr $numeVblo(IN)]                             -background grey80
$nn.vout  configure -text [expr $numeNoto(UA)+$numeNoto(US)]                -background grey80
$nn.vinput  configure -text [expr $numeVblo(IN)-$numeNoto(IN)]              -background grey80
if { [expr $numeNoto(UA)+$numeNoto(US)] != $numeVblo(IN)-$numeNoto(IN)} {
  $nn.vimp   configure -background yellow 
  $nn.vrich  configure -background yellow 
  $nn.vout   configure -background yellow 
  $nn.vinput configure -background yellow
}
	

}

#proc clickmod { c2 } {
#global f14File
#tk_messageBox -message "clickmod: $c2 - $f14File "
#                    set coo [$c2 coords current] 
#	            checkf14 $c2
##         tk_messageBox -message "$c2 - $coo"
#                    showOptions $c2 [lindex $coo 0] [lindex $coo 1]
#}
#
#
proc createcanvaDAT { f } {

global env
global wsBackg wsWidth wsHeight wsScrWidth 
global wsScrHeight wsXsiz wsYsiz wsXmin wsYmin 

global nn nn2

global  numeVblo   numeNoto

#tk_messageBox -message "qq" -type ok
set c2 $f.canDAT



##GUAG
#
  set nn $f.noti

  frame $nn
#  label noti.rich -width 17 -justify left -pady 3m -font "Times 12" \
#                                         -text "Tolerance " -anchor w
 label $nn.rich    -text "  knowns required " -anchor w                                         
  label $nn.vrich   -text "0 " -anchor w                                         
  label $nn.imp     -text "  knowns  " -anchor w                                         
  label $nn.vimp    -text "0 " -anchor w                                         
  label $nn.out     -text "  known outputs " -anchor w                                         
  label $nn.vout    -text "0 " -anchor w                                        
  label $nn.input   -text "  unknown inputs " -anchor w                                       
  label $nn.vinput  -text "0 " -anchor w

  set nn2 $f.bottoni1
  frame $nn2

  set nn4 $f.bottoni2
  frame $nn4

  button $nn2.golg3 -text "Compute steady state" -command "golg3 1 $c2 " -background green -foreground black -activebackground  red
  image create photo steady1 -file $env(LG_TIX)/img/regime.gif     
  set compo1 [image create compound -window $nn2.golg3 ]
#  $compo1 add space -width 2
  $compo1 add text -text "Compute steady state" 
  $compo1 add line 
  $compo1 add image -image steady1 

  $nn2.golg3 config -image $compo1

  button $nn2.calc_trans -text "Compute  Transient" -state normal  -background green -foreground black -activebackground  red -command {
               if { $modified1 == 1 } { 
                tk_messageBox -icon warning -type ok \
                 -title Warning -parent . -message "Model Data modified. Compute Steady State please!"
	       } else { calc_transient }  
              }
  image create photo trans1 -file $env(LG_TIX)/img/transitorio.gif
  set compo1 [image create compound -window $nn2.calc_trans ]
  $compo1 add text -text "Compute  Transient    "
  $compo1 add line 
  $compo1 add image -image trans1
  $nn2.calc_trans config -image $compo1

  if  { $::tcl_platform(os) != "Linux" } {
  button $nn2.watch -text "Plot Trends" -state normal -command { watchtrends 0 "lgsincro_temp.f22"}
  } else {
  button $nn2.watch -text "Plot trends" -state normal -command { watchtrends 1 "f22circ"}
  }

#  button $nn2.watch -text "Watch trends" -state normal -command {watchtrends 0 }

  button $nn2.edit -text "Edit F14" -state normal -command {

        set filelist [split $f14File /]
        if ![string compare [lindex $filelist [expr [llength $filelist]-1]] f14.dat] {
	       if { $modified1 == 1 } {
                set mex [tk_messageBox -icon warning -type yesno \
                 -title Warning -parent . -message "Model Data modified. Save f14...?"]
	        if {$mex == "yes"} {  saveF01 }
	       }	
       set editor $env(LG_TEXTEDITOR)
       catch [exec $editor [file dirname $f14File]/f14.dat &]
#      edit [file dirname $f14File]/f14.dat $tk_strictMotif
        } else {
#	   catch {destroy .top2}
#           toplevel .top2
#           label .top2.lab -text "A model must be selected !!" -font "Times 14"
#           button .top2.ok -text OK -command "destroy .top2"
#           pack .top2.lab -padx 3m -pady 3m -fill x -side top
#           pack .top2.ok -expand 1 -side bottom
   tk_messageBox -message "No Model is selected!" -type ok -icon error 
        }
  }

#fine GUAG


label $nn2.label1 -text "Steady state" -font "Times 14 bold" 
label $nn2.label2 -text "Transient" -font "Times 14 bold" 
label $nn2.label3 -text " " -font "Times 14 bold" 

#pack $nn2.label -side top 
#pack $nn2.sep -side top -fill x -expand no

#  pack $nn -side top -padx 2m -padx 2m -anchor w  
#  pack $nn.lg3txt $nn.golg3 $nn.rich $nn.vrich $nn.imp $nn.vimp $nn.out $nn.vout $nn.input $nn.vinput -side left




#set wsBackg gray90
set wsBackg  MistyRose1
#set wsBackg  White
set wsWidth 512
set wsHeight 384
set wsScrWidth 800
set wsScrHeight 600
set wsXsiz $wsScrWidth
set wsYsiz $wsScrHeight
set wsXmin $wsWidth
set wsYmin $wsHeight

canvas $c2 -bg $wsBackg -scrollregion [list 0 0 $wsScrWidth $wsScrHeight] \
	-width $wsWidth -height $wsHeight -xscrollcommand "$f.hscroll set" \
	-yscrollcommand "$f.vscroll set"
scrollbar $f.vscroll -command "$c2 yview"
scrollbar $f.hscroll -orient horiz -command "$c2 xview"

grid $c2 -in $f -row 0 -column 0 -rowspan 1 -columnspan 1 -sticky news

grid $f.vscroll -row 0 -column 1 -rowspan 1 -columnspan 1 -sticky news
grid $f.hscroll -row 1 -column 0 -rowspan 1 -columnspan 1 -sticky news

grid $nn2 -row 0 -column 2 -rowspan 1 -columnspan 1 -sticky nw
grid $nn2.label1 -row 1 -column 2 -rowspan 1 -columnspan 1 -pady 1m 
grid $nn2.golg3 -row 2 -column 2 -rowspan 1 -columnspan 1 -pady 1m
grid $nn2.edit -row 3 -column 2 -rowspan 1 -columnspan 1 -pady 1m

grid $nn2.label3 -row 4 -column 2 -rowspan 1 -columnspan 1 -pady 1c
grid $nn2.label2 -row 5 -column 2 -rowspan 1 -columnspan 1 -pady 1m
grid $nn2.calc_trans -row 6 -column 2 -rowspan 1 -columnspan 1 -pady 1m
grid $nn2.watch -row 7 -column 2 -rowspan 1 -columnspan 1 -pady 1m

grid $nn -row 2 -column 0 -rowspan 1 -columnspan 1 -sticky w
grid $nn.rich -row 2 -column 2 -rowspan 1 -columnspan 1 -sticky w
grid $nn.vrich -row 2 -column 3 -rowspan 1 -columnspan 1 -sticky w
grid $nn.imp  -row 2 -column 4 -rowspan 1 -columnspan 1 -sticky w
grid $nn.vimp -row 2 -column 5 -rowspan 1 -columnspan 1 -sticky w

grid $nn.out -row 2 -column 6 -rowspan 1 -columnspan 1 -sticky w
grid $nn.vout -row 2 -column 7 -rowspan 1 -columnspan 1 -sticky w
grid $nn.input -row 2 -column 8 -rowspan 1 -columnspan 1 -sticky w
grid $nn.vinput -row 2 -column 9 -rowspan 1 -columnspan 1 -sticky w


grid rowconfig $f 0 -weight 1 -minsize 0
grid columnconfig $f 0 -weight 1 -minsize 0

#images
set pixmapPath "$env(LG_PIXMAPS)"
set olddir [pwd]
cd $pixmapPath
foreach singleconn [glob -nocomplain {????_[news].ppm}] {
	image create photo [file rootname $singleconn] -file [file join $pixmapPath $singleconn]
}
image create photo portActive -file [file join $pixmapPath actconn.ppm]
cd $olddir




$c2 bind module <1> {
                     set tags_curr [$c2 gettags current]
                     if {[lsearch -exact $tags_curr  remarkdescr] == -1} { 
# NON è un remark...                    
                       set coo [$c2 coords current] 
	               checkf14 $c2
#         tk_messageBox -message "$c2 - $coo"
                       showOptions $c2 [lindex $coo 0] [lindex $coo 1]
                     }
  }


#$c2 bind module <1> "clickmod $c2"



#bind $c2 <1> {
#                set coo [$c2 coords current] 
#                 if { $coo == {} } { catch {$c2 delete modOpt}
#                 } else {                 
##         tk_messageBox -message "$c2 - $coo"
#                    showOptions $c2 [lindex $coo 0] [lindex $coo 1]
#                   }
#}
#

#bind $c2 <MouseWheel> {
#tk_messageBox -message "eccomi"
#    %W yview scroll [expr {- (%D / 120) * 4}] units
#}


#
#  pack $nn.lg3txt $nn.golg3 $nn.rich $nn.vrich $nn.imp $nn.vimp $nn.out $nn.vout $nn.input $nn.vinput -side left
#  pack $nn -side top -padx 2m -padx 2m -anchor w

#GUAG2012
if { $::LINUXNOMATLAB != 1 } {
# se PC
  $c2 bind port <Alt-ButtonPress-3> "showMathVar $c2 %x %y"
} else {
# se linux
  $c2 bind port <Shift-Alt-ButtonPress-3> "showMathVar $c2 %x %y"
}
bind $c2 <Alt-ButtonRelease-3> "destroyMathVar $c2"

#fine GUAG2012

return $c2

}




proc apri_modello { c c2 modo } {

# modo 0 viene da open model... e quindi non richiede il path del modello
# e quindi visualizza la window standard di apertura dei file


global  curFileName activeModel DIRMODEL f14File numeNoto nn nn2 f14time
global modified needbuild
#tk_messageBox -message "apri_modello: $curFileName modo=$modo"
if {$curFileName == "-"} {set curFileName "" }

if { $modo == 0 } {
	if { [ topRead $c {} ]} { return 2 }
}

if { $modo != 0 } {
	if { [topRead $c [file rootname $curFileName]]} { return 2 }
}


#
#set ret11 0
#if { $modo == 0 } { set ret11 [ topRead $c {} ] }
#if { $ret11 == "2" } { return 2 }
#
#if { $modo != 0 } {topRead $c [file rootname $curFileName]}
#

#tk_messageBox -message "1 $curFileName"
cd [ file dirname $curFileName ]

 if  { $::LINUXPLAT == 0 } {
 set test "proc/f14.dat"
 } else {
 set test "proc/first"
 }

if { ![file exists $test]} {
#tk_messageBox -message "nnon c "
set modified 1
set needbuild 1
      if { $::LINUXPLAT == 0 } {
              if { ![buildLegoFiles $c]} {return 2 }
      } else {
              if { ![buildLegoFiles_linux $c]} {return 2 } 
      }
}

## GUAG 22 maggio 2007 - evito la ricostruzione della canvas dati, tanto viene ricostruita quando si apre dati!
##if { [topRead $c2 [file rootname $curFileName]]} { return 2 }
###tk_messageBox -message "2 $curFileName"
##if { ![loadF01 $c2 yes]} { return 2}
##$nn2.golg3 configure -state normal 
##$nn2.calc_trans configure -state normal
##agg_vis_noti
##
set activeModel [file rootname [file tail $curFileName]]
set DIRMODEL [ file dirname $curFileName ]
set f14File $DIRMODEL/f14.dat
#tk_messageBox -message " $c2 - $curFileName - $DIRMODEL - $f14File"

file stat $f14File statis
set f14time $statis(atime) 

return 0

}

proc avverti { c } {
global modified modified1 needbuild fileChange

	       if { $modified == 1 } {
                set mex [tk_messageBox -icon warning -type yesno \
                 -title Warning -parent . -message "1 Model topology modified. Save...?"]
	        	if {$mex == "yes"} {
				if {[topWrite $c save]} {return 1}
			} else {return 1}
	       }

	      if { $needbuild == 1 } {
                   set mex [tk_messageBox -icon warning -type yesno \
                    -title Warning -parent . -message "2 Model topology modified. Save f01...?"]
   	            if {$mex == "yes"} {                         
                        if { $::LINUXPLAT == 0 } {	
                           if { ![buildLegoFiles $c]} {return 2}
   	                } else {      
   			   if { ![buildLegoFiles_linux $c]} {return 2}
   	                }             
   	       	    } else {return 2} 
	       }                                
                          
	       if { $modified1 == 1 } {
                set mex [tk_messageBox -icon warning -type yesno \
                 -title Warning -parent . -message "3 Model Data modified. Save f14...?"]
	        	if {$mex == "yes"} {
				if { ![saveF01] } {return 3}
			} else {return 3}
	       }
	       
	       	  
	       if { $fileChange == "YES" } {
                	set mex [tk_messageBox -icon warning -type yesno \
                 	-title Warning -parent . -message "Task configuration modified. Save Simulator...?"]
	        	if {$mex == "yes"} {
				save_task_cb;
				ok_simul
			} else {return 4}
			#JJ gestire return 4
	       }
#tk_messageBox  -message "avverti: fine regolare"
	       return 0
}


source $env(LG_TIX)/animate.tcl

proc ShowNamesfilt { c c2 mod } {
global modalita lgsincropid
if { $mod == 5 } {
#modo debug per fare alcune stampe
set qq [$c2 gettags infoitemname ]
#tk_messageBox  -message "ITEM: $item\n 0: [lindex [$c gettags $item] 0 ]\n 1: [lindex [$c gettags $item] 1 ]\n 2: [lindex [$c gettags $item] 2 ]\n 3: [lindex [$c gettags $item] 3 ]\n 4: [lindex [$c gettags $item] 4 ]\n 5: [lindex [$c gettags $item] 5 ]\n"

tk_messageBox  -message "ShowNamesfilt: $c2: $qq\n [ lindex $qq 0]\n [ lindex $qq 1]\n [ lindex $qq 2]\n [ lindex $qq 3]\n" 
set mod 4
}
	if { $mod == 4 } {

          if  { $::LINUXPLAT == 1 } {
            puts "ShowNamesfilt: eccomi 1 mod=$mod"	
              set lgsincropid 1
          }

          if  { $::LINUXPLAT == 0 } {
# per window
#se si vuole togliere il blocco sulla assenza di lgsincro, scommetare la successiva...
              if  { $lgsincropid == -1 } { set lgsincropid 1 }
          }

# metto in animazione lo schema con i valori del transitorio
    	if { $lgsincropid != -1 } {
puts "ShowNamesfilt: eccomi  2 mod=$mod"
          if { [ esiste_processo $lgsincropid ] == 1  } { 
### GUAG commento per anestetizzare la funzione
		anima init qq
		anima_aggiorna $c2 1 
           } 	 
      	}
	} else {
		anima chiudi qq
	    ShowNames $c $mod
	    ShowNames $c2 $mod	
	}
}

proc DupModel { c c2 c4} {

	global envir
	global env curFileName modified DIRMODEL
	global wsXsiz wsYsiz

	if {$curFileName == "untitled" || $curFileName == "" || $curFileName == "-"} {
		set messaggio "No Model to 'Save As...'"
		tk_messageBox -message $messaggio -type ok -icon error
		return
	}

	toplevel $c.dupmod
	wm title $c.dupmod "ModelName Duplication"
	set curmodel [ file tail [ file dirname  $curFileName ] ]
	label $c.dupmod.lab -text "Copy current model $curmodel to:" -font "Courier 12"
	entry $c.dupmod.ent -textvariable modelName
	frame $c.dupmod.but
	
	button $c.dupmod.but.ok -text OK -command {
          if [file isdirectory $env(LG_MODELS)/$modelName] {
                tk_messageBox -icon info -message "model already exists!" \
                                    -type ok -parent .
	  } elseif {[string length $modelName] > 8} {
                tk_messageBox -icon warning -message "Model name too long (max 8 char.)" \
                                    -type ok -parent .
               
          } else {
		file mkdir $env(LG_MODELS)/$modelName
          file copy -force  $curFileName $env(LG_MODELS)/$modelName/${modelName}.tom
          catch { file copy -force  f14.dat $env(LG_MODELS)/$modelName }
          catch { file copy -force  f01.dat $env(LG_MODELS)/$modelName }
          catch { file copy -force  foraus.for $env(LG_MODELS)/$modelName }
          catch { file copy -force  tasks.dat $env(LG_MODELS)/$modelName }
          catch { file copy -force  simul.dat $env(LG_MODELS)/$modelName }
	  set modified 1
#	  set modified1 1
	  set curFileName $env(LG_MODELS)/${modelName}/${modelName}.tom

#	  apri_modello $c $c2 1
	  
          if {[apri_modello $c $c2 1]} {return 1}
	  ShowNamesfilt $c $c2 $showon
	  if { $::LINUXNOMATLAB != 1 } {
	   open_simul $f4 $DIRMODEL/tasks.dat;
	   load_task $DIRMODEL $c4;
	  }

          }
          destroy $c.dupmod     
	}
	
	button $c.dupmod.but.canc -text Canc -command {
		destroy $c.dupmod
		return
	}
	pack $c.dupmod.but.ok $c.dupmod.but.canc -side left -padx 2m -fill x
	pack $c.dupmod.lab $c.dupmod.ent $c.dupmod.but -side top -pady 3m -padx 2m

} 


proc saveSN {}  {
	global env SerialNumber
	toplevel .sn
	wm title .sn "License"
	label .sn.lab -text "Enter S/N:" -font "Courier 12"
	entry .sn.ent -textvariable SerialNumber -width 22 -state disabled
	set lounlo "Locked"
	checkbutton .sn.unlock -indicatoron 0 -background red -activebackground green \
	  -text $lounlo -textvariable lounlo -font "Courier 12" -command { 
	    if { $lounlo == "Locked" } {
	       set lounlo "Unlocked"
	       .sn.unlock configure -background green
	       .sn.ent configure -state normal 
	    } else { set lounlo "Locked" 
	       .sn.unlock configure -background red
	       .sn.ent configure -state disabled }
	    }

	frame .sn.but
        if [file exists $env(LG_LEGO)/lmf.dat] {
           set f [checkopen $env(LG_LEGO)/lmf.dat r]
           gets $f SerialNumber
	   close $f
        }
	button .sn.but.ok -text OK -command {
		set f [checkopen $env(LG_LEGO)/lmf.dat w]
		puts $f $SerialNumber
		close $f
		destroy .sn
		return
        }
	button .sn.but.canc -text Canc -command {
		destroy .sn
		return
	}
pack  .sn.but -side bottom -pady 3m -padx 2m
	pack .sn.lab -side top -pady 3m -padx 2m
	pack .sn.unlock .sn.ent

	pack .sn.but.ok .sn.but.canc -side left -padx 6m -fill x


}
proc lanciaTables {} {
	global env
	set comm1 [info nameofexecutable]
	set comm2 "$env(LG_TABLES)/tables.tcl"
	exec $comm1 -f $comm2 &
}

proc lanciaLib {} {
	global env
	set comm1 [info nameofexecutable]
	set comm2 "$env(LG_TIX)/libraria.tix"
	exec $comm1 -f $comm2 &
}

proc autoedi14 {} {
	global env activeModel curFileName
#	set editor notepad
#	set editor $env(LG_LEGO)/edita.bat
#     if {$curpath == "(none)"} { return  }
      
#       set modeldir $env(LG_MODELS)/$activeModel
#       cd $modeldir
       set modeldir   [file dirname $curFileName]
       cd $modeldir
       

       if {![file exists f14.dat]} {
       	file copy  proc/f14.dat f14.dat 
         return
       }
       catch { file copy proc/f14.dat_back1 proc/f14.dat_back2 }
       file copy -force f14.dat proc/f14.dat_back1      
       file copy -force proc/f14.dat f14.dat      

       set sorgf14 [ file join $modeldir proc/f14.dat_back1 ]

       set f [checkopen edi14.inp w]
       puts $f $sorgf14
       close $f
       
       exec $env(LG_LEGO)/edi14 <edi14.inp
       file delete -force edi14.inp



        file copy -force edi14.out f14.dat
        

}

proc lanciaedi14 {c c2 } {
        global env activeModel
        global  curFileName
	if {$curFileName == "untitled" || $curFileName == "" || $curFileName == "-"} {
		set messaggio "No Model is selected!"
		tk_messageBox -message $messaggio -type ok -icon error
		return
	}

        set editor $env(LG_TEXTEDITOR)
#	set editor $env(LG_LEGO)/edita.bat
#tk_messageBox -message "lanciaedi14: $editor" -type ok

      if  { $::tcl_platform(os) == "Linux" } {
      set comedi14 "$env(LEGO_BIN)/edi14c"
      } else {
      set comedi14 "$env(LG_LEGO)/edi14"
      }



      if {$activeModel != "(none)"} {
       set modeldir $env(LG_MODELS)/$activeModel
       cd $modeldir
       if {![file exists f14.dat]} {
        if [file exists proc/f14.dat] {
         file copy -force proc/f14.dat f14.dat
        } else {
         tk_messageBox -message "The file f14.dat of the model $activeModel does not exist" -type ok -icon warning -title Warning
         return
        }
       }
	 set types {
		{"dat files"		{.dat}	}
		{"All files"		*}
	 }
	 set curFileNamef14 [tk_getOpenFile -filetypes $types -parent . -title "Edi14 File Selection" -initialdir $env(LG_MODELS)]

	 if {![file exists $curFileName]} {
		tk_messageBox -message "File $curFileNamef14 not found..." -type ok -title "Warning"
		set curFileNamef14 ""
            return
	 }
       set f [checkopen edi14.inp w]
       puts $f $curFileNamef14
       close $f


       catch {exec $comedi14 < edi14.inp}
       file delete -force edi14.inp

       set mex1 [tk_messageBox -message "Do you want to view Edi14 results?"\
                -type yesno -icon question -title "Question"]
       if {$mex1 == "yes"} {
#        exec $env(LG_LEGO)/edita.bat edi14.out
	 set editor $env(LG_TEXTEDITOR)
	 catch {exec $editor edi14.out &}

       }

       set mex2 [tk_messageBox -message "Do you want to save results on file f14.dat\
                 of the model $activeModel ?" -type yesno -icon question -title "Question"]
       if {$mex2 == "yes"} {
        file copy -force edi14.out f14.dat
        raisedata $c $c2
        tk_messageBox -message "Results correctly saved" -type ok -icon info
       }
      } else {
	 tk_messageBox -message "You must select a model" -type ok -icon warning -title "Warning"
	}
}

proc lanciaForaus {} {
	global env activeModel
        global  curFileName
	if {$curFileName == "untitled" || $curFileName == "" || $curFileName == "-"} {
		set messaggio "No Model is selected!"
		tk_messageBox -message $messaggio -type ok -icon error
		return
	}
		
	set comm1 [info nameofexecutable]
	set comm2 "$env(LG_TIX)/foraus.tix"
      set dirmod [file join $env(LG_MODELS) $activeModel]
      if {$activeModel != "(none)"} {
       if {![file exists $dirmod/foraus.for]} {
        tk_messageBox -message "The file foraus.for doesnt't exist" -type ok -icon warning
        return
       } elseif {![file exists $dirmod/f01.dat]} {
        tk_messageBox -message "The file f01.dat doesnt't exist" -type ok -icon warning
        return 
       }
       exec $comm1 -f $comm2 $activeModel &
	} else {
       tk_messageBox -message "You must select a model" -type ok -icon warning -title "Warning"	
	}

}

proc lancia_edit_tasks {} {
	global env activeModel
	set comm1 [info nameofexecutable]
	set comm2 "$env(LG_TIX)/edit_tasks.tix"
        exec $comm1 -f $comm2 &
}

proc lancia_PostProc {} {
	global env activeModel
	set comm1 [info nameofexecutable]
	set comm2 "$env(LG_POSTPROC)/postproc.tix"
        exec $comm1 -f $comm2 &
}

proc CreateBanner {} {
   global env
   toplevel .relinfo
   wm title .relinfo "LegoPc Release Info"
   frame .relinfo.frame 
   catch {image delete imglego}
   image create photo imglego -file $env(LG_TIX)/img/lego.gif
   label .relinfo.frame.imglego -image imglego -bd 1 -relief sunken
   label .relinfo.frame.text -justify left -padx 2m -pady 5m -font "Times 16 bold" \
               -text "\n\nLegoPc System\n\nBuild: 7.1\n\n\n"
   pack .relinfo.frame.imglego .relinfo.frame.text -side left -padx 1m
#   frame .relinfo.but  -relief ridge -borderwidth 2
   frame .relinfo.but  
   button .relinfo.but.ok -text "OK" -width 8 -font "Times 12" -command "destroy .relinfo"
   button .relinfo.but.rn -text "Release Notes" -width 12 -font "Times 12" \
          -command {catch {exec $env(LG_LEGO)/edita.bat [join [split $env(LG_INSTALL)/relnotes.txt / ] \\ ] &}}
   pack .relinfo.but.rn .relinfo.but.ok -side left -padx 8m
   pack .relinfo.frame .relinfo.but -side top -pady 1m
}


# accessory files
source $env(LG_TIX)/golg3_v2.tcl
source $env(LG_TIX)/simul_v2.tix

source $env(LG_TIX)/read_con.tcl
source $env(LG_TIX)/itemjoin.tcl
source $env(LG_TIX)/viewmgr.tcl
source $env(LG_TIX)/fileio.tcl
source $env(LG_TIX)/rotate.tcl
source $env(LG_TIX)/legodat_v2.tix
source $env(LG_TIX)/openhelp.tcl

proc raisetopol { c } {
	   	global showon  curFileName
		global model_img data_img  task_img modalita
    		set modalita 1
		if { [avverti $c]} { return 1}

    		if { [topRead $c [file rootname $curFileName]]} { return 1}

    		if { $::showon == 4 } { set qq [$c gettags infoitemname ]; anima chiudi qq }
		
		ShowNames $c $showon
		.menu.file entryconfigure 0 -state normal 
		.menu.file entryconfigure 2 -state normal 
		.menu.file entryconfigure 3 -state normal 
		.menu.file entryconfigure 4 -state normal
# 5 è separator 
		.menu.file entryconfigure 6 -state normal 
		.menu.file entryconfigure 7 -state disabled 
# 8 è separator 
		.menu.file entryconfigure 9 -state normal 
# 10 è separator 
		.menu.file entryconfigure 11 -state normal 
		.menu.lib  entryconfigure 0 -state normal 
		.menu.lib  entryconfigure 1 -state normal 
		.menu.view  entryconfigure 0 -state normal 
		.menu.view  entryconfigure 1 -state normal 
          if  { $::LINUXPLAT == 1 } {
		.menu.view  entryconfigure 2 -state normal
		} else {
		.menu.view  entryconfigure 3 -state normal
               }		 
		.menu.view  entryconfigure 4 -state normal 
		.menu.view  entryconfigure 5 -state normal 
		.menu.util  entryconfigure 5 -state normal 
		.menu.util  entryconfigure 6 -state normal 
		$model_img configure -showbackground 1
		$data_img configure -showbackground 0
		$task_img configure -showbackground 0
}

proc raisedata { c c2 } {
		global nn nn2 showon curFileName 
		global model_img data_img task_img modalita
		set modalita 2
#tk_messageBox -message "raisedata: eccomi"
                set ret_val [avverti $c]
        	if { $ret_val==1 | $ret_val==2} {
#tk_messageBox -message "raisedata: avverti1"
        			return 1
        		}
        	if { [topRead $c2 [file rootname $curFileName]]} {
        			return 1
        		}
        	if { ![loadF01 $c2 no]} {
        			return 2
        		}
        				
		ShowNames $c2 $showon
		$nn2.golg3 configure -state disable 
		$nn2.calc_trans configure -state disable	
		if {$curFileName != "untitled" && $curFileName != "" && $curFileName != "-"} { $nn2.golg3 configure -state normal ; $nn2.calc_trans configure -state normal ; agg_vis_noti }
		.menu.file entryconfigure 0 -state disabled 
		.menu.file entryconfigure 2 -state disabled 
		.menu.file entryconfigure 3 -state disabled 
		.menu.file entryconfigure 4 -state disabled
		.menu.file entryconfigure 6 -state disabled
		.menu.file entryconfigure 7 -state normal 
		.menu.file entryconfigure 9 -state disabled 
		.menu.file entryconfigure 11 -state normal 
		.menu.lib  entryconfigure 0 -state disabled 
		.menu.lib  entryconfigure 1 -state disabled 
		.menu.view  entryconfigure 0 -state disabled 
		.menu.view  entryconfigure 1 -state disabled 
          if  { $::LINUXPLAT == 1 } {
		.menu.view  entryconfigure 2 -state normal
		} else {
		.menu.view  entryconfigure 3 -state normal
               }		 
		.menu.view  entryconfigure 4 -state normal 
		.menu.view  entryconfigure 5 -state normal 
		.menu.util  entryconfigure 5 -state disabled 
		.menu.util  entryconfigure 6 -state disabled 
		$model_img configure -showbackground 0
		$data_img configure -showbackground 1
		$task_img configure -showbackground 0
                return 0
}

proc raisetaskconf { c c2 c4 } { 
	global model_img data_img task_img showon curSimulPathName DIRMODEL modalita
	set modalita 3
	avverti $c
    	
    	if { $::showon == 4 } { set qq [$c4 gettags infoitemname ]; anima chiudi qq}

	ShowNames $c4 $showon
	.menu.file entryconfigure 0 -state disabled 
	.menu.file entryconfigure 2 -state disabled 
	.menu.file entryconfigure 3 -state disabled 
	.menu.file entryconfigure 4 -state disabled 
	.menu.file entryconfigure 6 -state disabled
	.menu.file entryconfigure 7 -state disabled 
	.menu.file entryconfigure 9 -state disabled 
	.menu.file entryconfigure 11 -state disabled 
	.menu.lib  entryconfigure 0 -state disabled 
	.menu.lib  entryconfigure 1 -state disabled 
	.menu.view  entryconfigure 0 -state disabled 
	.menu.view  entryconfigure 1 -state disabled 
          if  { $::LINUXPLAT == 1 } {
		.menu.view  entryconfigure 2 -state normal
		} else {
		.menu.view  entryconfigure 3 -state normal
               }		 
	.menu.view  entryconfigure 4 -state normal 
	.menu.view  entryconfigure 5 -state normal 
	.menu.util  entryconfigure 5 -state normal 
	.menu.util  entryconfigure 6 -state normal 
	$model_img configure -showbackground 0
	$data_img configure -showbackground 0
	$task_img configure -showbackground 1
        if { $DIRMODEL != "" } { load_task $DIRMODEL $c4 }	
#       if { $curSimulPathName != "" } { load_task $curSimulPathName $c4 }
#	lancia_load_task  $c4  $c $c2
}


source $env(LG_TIX)/edit_tasks_v3.tix
proc createtask { f c c2} {
	global DIRMODEL
	set c4 [edit_tasks $f $DIRMODEL  $c $c2 ]
	return $c4
}



#####################################################
#
# MAIN 
#
#####################################################


    global model_img data_img task_img curSimulPathName, modalita
	set modalita 0
    set oldeimage ""
    set curTool none
    set progNumb 0
    set progName "name"
    set palId 0
    set jshift .5
    set portw 12
    set porth 12
    set modified 0
    set modified1 0
    set needbuild 0
    set f14time 0
    set showon 2
    set DIRMODEL " "
    set ::fileChange "NO"
    set ::select_list " "

# Opzioni steady state di default
    set calcmode 1
    set jacob 0
    set damp 0
    set tolerance 0.00001
    set peso0 0.01
    set epsilon 1.D-5
    set percent 0.1
    
    #set numeNoto(UA) 0
    #set numeNoto(US) 0
    #set numeNoto(IN) 0
    #set numeVblo(IN) 0
#switchuser
    set entr1 $env(LG_ENTRY)
    set entr [file tail $entr1]
#tk_messageBox -message "USER:  entr1:$entr1 entr:$entr" -type ok
    set envir "LegoPC-$entr"
    
    
    set curFileName "-"
    set curSimulPathName ""
    wm title . "$envir- $curFileName"
    wm protocol . WM_DELETE_WINDOW "WarnYou exit"

    #wm iconbitmap .  "D:/Utili/icons/temp/animali/118.ico"
    #set c .frame.c
     
    cd $env(LG_MODELS)
    
    frame .indice
    
    pack .indice -side top  -anchor w -fill both -expand yes
    
    set w .indice
#
# Configurazione del widget NoteBook
#
    # We use these options to set the sizes of the subwidgets inside the
    # notebook, so that they are well-aligned on the screen.
    #
    set name [tixOptionName $w]
    option add *$name*TixControl*entry.width 10
    option add *$name*TixControl*label.width 18
    option add *$name*TixControl*label.anchor e

    # Create the notebook widget and set its backpagecolor to gray.
    # Note that the -backpagecolor option belongs to the "nbframe"
    # subwidget.
 
    # $w config -bg gray
    # $w.nb subwidget nbframe config -backpagecolor gray

    # Create the two tabs on the notebook. The -underline option
    # puts a underline on the first character of the labels of the tabs.
    # Keyboard accelerators will be defined automatically according
    # to the underlined character.	
    #


    if { $::LINUXPLAT == 0 } { 
    	tixNoteBook $w.nb -ipadx 6 -ipady 6
    image create photo fase1 -file $env(LG_TIX)/img/fase1.gif
    image create photo fase2 -file $env(LG_TIX)/img/fase3.gif
    image create photo fase3 -file $env(LG_TIX)/img/fase3.gif
    image create photo fase4 -file $env(LG_TIX)/img/fase4.gif

    set model_img [image create compound -window [$w.nb subwidget nbframe] \
	-pady 4 -padx 4 -bg #9090f0 -showbackground 0 ]
    $model_img add line
    $model_img add image -image fase1
    $model_img add space -width 1
    $model_img add text -text "Model Topology" -underline 0 -padx 6 -pady 4    
    # Create the second compound image. Very similar to what we did above
    #
    set data_img [image create compound -window [$w.nb subwidget nbframe] \
	-pady 4 -pady 4 -bg #f09090 -showbackground 0]
    $data_img add line
    $data_img add image -image fase2
    $data_img add space -width 1
    $data_img add text -text "Data Assignment\n&\nSimulation" -underline 0 -padx 6 -pady 4

    $w.nb add model_topol -image $model_img -underline 0
    $w.nb add data_ass    -image $data_img  -underline 0

    } else { 
	tixNoteBook $w.nb
    image create photo fase1 -file $env(LG_TIX)/img/fase1.gif
    image create photo fase2 -file $env(LG_TIX)/img/fase3.gif
    image create photo fase3 -file $env(LG_TIX)/img/fase3.gif
    image create photo fase4 -file $env(LG_TIX)/img/fase4.gif

    	set model_img [image create compound -window [$w.nb subwidget nbframe] \
        -bg #9090f0 -showbackground 0]
    $model_img add line
    $model_img add image -image fase1
    $model_img add space -width 1
    $model_img add text -text "Model Topology" -underline 0
    # Create the second compound image. Very similar to what we did above
    #
    set data_img [image create compound -window [$w.nb subwidget nbframe] -bg #f09090 -showbackground 0]
    $data_img add line
    $data_img add image -image fase2
    $data_img add space -width 1
    $data_img add text -text "Data Assignment\n&\nSimulation" -underline 0
# GUAG tolgo i widget compo, non compatibili con tix 8.4
##    $w.nb add model_topol -image $model_img -underline 0
##    $w.nb add data_ass    -image $data_img  -underline 0

#  solo immagine funziona
#    $w.nb add model_topol -image fase1 -underline 0
#    $w.nb add data_ass -image fase2 -underline 0
# scelgo solo testo
    $w.nb add model_topol -label "Model Topology" -underline 0
    $w.nb add data_ass    -label "Data Assignment\n&\nSimulation"  -underline 0

# Create the balloon widget and associate it with the widgets that we want
# to provide tips for:
#    label $w.status -width 40 -relief sunken -bd 1
#    tixBalloon $w.b -statusbar $w.status
#    set f [$w.nb subwidget model_topol]
#    set f2 [$w.nb subwidget data_ass]
#    $w.b bind $f -balloonmsg "Close window" \
#	-statusmsg "Press this button to close this window" 
#    $w.b bind $f2 -balloonmsg "Self-destruct\nButton" \
#	-statusmsg "Press this button and it will get rid of itself" 

    }
 

    set task_img [image create compound -window [$w.nb subwidget nbframe] \
	-pady 4 -pady 4 -bg green -showbackground 0]
    $task_img add line
    $task_img add image -image fase4
    $task_img add space -width 1
    $task_img add text -text "Task Configure" -underline 0 -padx 6 -pady 4

##    $w.nb add model_topol -image $model_img -underline 0
##    $w.nb add data_ass    -image $data_img  -underline 0

# non va per linux    $w.nb add simul       -image $simul_img -underline 0


    if  { $::LINUXNOMATLAB != 1 } {$w.nb add task_conf   -image $task_img  -underline 0 }

    set f [$w.nb subwidget model_topol]
    set c [ createcanva $f ]


    set f2 [$w.nb subwidget data_ass]
    set c2 [ createcanvaDAT $f2 ]

set ::cglob $c

#    set f3 [$w.nb subwidget simul]
#    createsimul $f3 
#tk_messageBox -message "eccomi" -type ok -icon error
if  { $::LINUXNOMATLAB != 1 } {
   set f4 [$w.nb subwidget task_conf]
   set c4 [createtask $f4 $c $c2 ]
} else {
# metto dei valori dummy che comunque non verranno mai usati
 set f4 "QQ"
 set c4 "QQ"
}

#
# Configurazione del menu
#    
    menu .menu -tearoff 0

    set m .menu.file

    menu $m -tearoff 0 -activebackground darkblue -activeforeground white
    .menu add cascade -label "File" -menu $m -underline 0
    set newcmd {
	set model_name [lindex [file split [file dirname $curFileName]] end]
	if {$model_name == "."} {
		set model_name "untitled"
	}
	set mex [tk_messageBox -icon question -type yesno \
         -title Question -parent . -message "Do you want to quit\
          model: *** $model_name *** and start a new one from scratch?"]
	if {$mex == "yes"} {
		$c delete all 
		wm title . "LegoPC- untitled"
            .menu.file entryconfigure 4 -state disabled
            set curFileName untitled; set modified 0; set needbuild 0
	}
    }



    #append newcmd "; set curFileName untitled; set modified 0; set needbuild 0"
    $m add command -label "New Model" -command $newcmd
    #$m add command -label "Open..." -command "topRead $c {}"
###    $m add command -label "Open Model..." -command { set ret11 0 ; set ret11 [ apri_modello $c $c2 0]; if { $ret11 == 2 } { return }; ShowNamesfilt $c $c2 $showon; open_simul $f4 $DIRMODEL/tasks.dat; load_task $DIRMODEL $c4 }

$m add command -label "Open Model..." -command { aprimodello $c $c2 $f4 0 }

#    $m add command -label "Open Model..." -command { 
#    	                        set ret11 0 
#    			 	set ret11 [ apri_modello $c $c2 0]
#    			  	if { $ret11 == 2 } { return }
#    			   	ShowNamesfilt $c $c2 $showon
#    			    	open_simul $f4 $DIRMODEL/tasks.dat
###    			     	load_task $DIRMODEL $c4 
#    			     }
#

#    $m add command -label "Save Model" -command { topWrite $c save; topRead $c [file rootname $curFileName]}
     $m add command -label "Save Model" -command " topWrite $c save "

#    $m add command -label "Save As..." -command "topWrite $c saveas"
    $m add command -label "Save As..." -command { . configure -cursor "watch"; DupModel $c $c2 $c4 ; . configure -cursor "arrow"}
    $m add command -label "Include model..." -command "include $c" -state disabled
    $m add separator
if { $::LINUXPLAT == 0 } {
    $m add command -label "Build F01/F14" -command { $c configure -cursor "watch" ; update ; buildLegoFiles $c;  $c configure -cursor "arrow" }
} else {
    $m add command -label "Build F01/F14" -command { $c configure -cursor "watch" ; update ; buildLegoFiles_linux $c;  $c configure -cursor "arrow" }
}
    $m add command -label "Save F01/F14" -command "saveF01" -state disabled
    $m add separator
    $m add command -label "Set canvas size" -command "sizeCanv $c both"
    $m add separator
    if { $::LINUXPLAT == 1 } {
    set modalita 1
    global modalita
    }
    $m add command -label "Postscript" -command "if { $modalita == 1} {plotPS $c2 } else { plotPS $c2 } "
     
#    $m add separator
#    $m add command -label "Duplicate Model" -command "DupModel $c $c2 $c4"
    $m add separator
if { $::LINUXPLAT == 0 } {
## solo per windows
    $m add command -label "Change user" -command "switchuser"
##
} else {
    $m add command -label "Import f01" -command "ImportF01 $c "
}	
    $m add separator
    $m add command -label "Exit" -command "WarnYou exit" 

#    $m add command -label "Quit" -command "WarnYou quit"
    
    set m .menu.lib
    menu $m -tearoff 0 -activebackground darkblue -activeforeground white
    .menu add cascade -label "Library" -menu $m -underline 0
#    $m add command -label "Open..." -command "createPal" -font "Courier 32"
    $m add command -label "Open..." -command "createPal"
    $m add command -label "Close all" -command "killAllPal"
    
    
    set m .menu.view
    menu $m -tearoff 0 -activebackground darkblue -activeforeground white
    .menu add cascade -label "View" -menu $m -underline 0
    $m add command -label "Links..." -command "optLinks $c"
    $m add command -label "Info..." -command "optInfo $c"

if { $::LINUXPLAT != 0 } {
#    $m add command -label "Set Sim path" -command {set ::anima_sim_path [tk_chooseDirectory -initialdir $::anima_sim_path] }
#    set ::anima_sim_path 0
    set simpath $m.simpath
    menu $simpath -tearoff 0 -activebackground darkblue -activeforeground white
    $m add cascade -label "Set Sim path" -menu $simpath -underline 0
#    $simpath add command -label [set ::anima_sim_path]
    $simpath add command -label [set ::anima_sim_path] -command {
    set ::anima_sim_path [tk_chooseDirectory -initialdir $::anima_sim_path -title "Choose simulator path"] 
    $simpath  entryconfigure 0 -label [set ::anima_sim_path]    }
    }

#    $m add separator
#    $m add command -label "Explore" -command {
#    	global curFileName DIRMODEL
##    	tk_messageBox -message "curFileName=$curFileName\n DIRMODEL=$DIRMODEL"
##    	exec $env(LG_BROWSER) [pwd]
#    	exec $env(LG_BROWSER) $DIRMODEL
#    	}
    
    $m add separator    
    $m add radio -label "Show OFF" -variable showon -value 1 -command "ShowNamesfilt $c $c2 1"
    $m add radio -label "Show Names" -variable showon -value 2 -command "ShowNamesfilt $c $c2 1; ShowNamesfilt $c $c2 2"
    $m add radio -label "Show Classes" -variable showon -value 3 -command "ShowNamesfilt $c $c2 1; ShowNamesfilt $c $c2 3"
    $m add radio -label "Show Value" -variable showon -value 4 -command "ShowNamesfilt $c $c2 1; ShowNamesfilt $c $c2 4"
    


set ::stileanim 1
set ::stileanim_prec $::stileanim    
    if { $::LINUXPLAT } {
    $m add checkbutton -label "StileAnim" -variable ::stileanim
    } else {
    $m add radio -label "Show infoitemname" -variable showon -value 4 -command "ShowNamesfilt $c $c2 5"
    }
    
    set m .menu.util
    menu $m -tearoff 0 -activebackground darkblue -activeforeground white
    .menu add cascade -label "Tools" -menu $m -underline 0 -activebackground darkblue -activeforeground white
    $m add command -label "Tables H20" -command lanciaTables
    $m add command -label "Librarian" -command lanciaLib
    $m add command -label "Edi14" -command "lanciaedi14 $c $c2"
    $m add command -label "Foraus" -command lanciaForaus
    $m add command -label "PostProc" -command lancia_PostProc
    
#    $m add command -label "Edit Tasks" -command lancia_edit_tasks
    $m add command -label "Transient batch" -command transient_batch

#    if  { $::tcl_platform(os) != "Linux" } {
#    } else {
#    $m add command -label "Steady State Options" -command ssopt_linux
#    $m add command -label "f01totom" -command "exec [info nameofexecutable] -f $env(LG_TIX)/f01totom.tcl &"
#    }
    
  if  { $::tcl_platform(os) != "Linux" } {
    $m add command -label "License mgr" -command saveSN
    $m add command -label "Steady State Options" -command ssopt
  
    $m add command -label "Explore" -command {
    	global curFileName DIRMODEL
        set nome_nativo [file nativename $DIRMODEL]
#    	tk_messageBox -message "curFileName=$curFileName\n DIRMODEL=$DIRMODEL\n nome_window=$nome_nativo"
#    	exec $env(LG_BROWSER) [pwd]
    	exec $env(LG_BROWSER) $nome_nativo &
}  

  
    set m .menu.grafics_ut
    menu $m -tearoff 0 -activebackground darkblue -activeforeground white
    .menu add cascade -label "Graf.Tools" -menu $m -underline 0 -activebackground darkblue -activeforeground white
    $m add command -label "Plot trends" -command {watchtrends 0 "proc/f22.dat"}
    $m add command -label "Graphics" -command {exec $env(LG_GRAF)/grafics &}
    $m add command -label "Convert f22 to ASCII" -command {to_ascii}
  } else {
    $m add command -label "Steady State Options" -command ssopt_linux
    $m add command -label "f01totom" -command "exec [info nameofexecutable] -f $env(LG_TIX)/f01totom.tcl &"
        $m add command -label "Xterm" -command {
    	global curFileName DIRMODEL
#    	tk_messageBox -message "curFileName=$curFileName\n DIRMODEL=$DIRMODEL"
#    	exec $env(LG_BROWSER) [pwd]
    	exec xterm &
}  

    set m .menu.grafics_ut
    menu $m -tearoff 0 -activebackground darkblue -activeforeground white
    .menu add cascade -label "Graf.Tools" -menu $m -underline 0 -activebackground darkblue -activeforeground white
    $m add command -label "Plot trends" -command {watchtrends 1 "f22circ"}
    $m add command -label "Graphics" -command {exec $env(LEGORT_BIN)/graphics &}
  }


    set m .menu.about
    menu $m -tearoff 0 -activebackground darkblue -activeforeground white
    .menu add cascade -label "?" -menu $m -underline 0 -activebackground darkblue -activeforeground white
    $m add command -label "Help" -command {open_hlp index}
    $m add command -label "About LegoPc" -command "CreateBanner"
    
    . configure -menu .menu
    
#
# ulteriore configurazione del widget NoteBook
#
        $w.nb pageconfigure model_topol -raisecmd {raisetopol $c }
        $w.nb pageconfigure data_ass -raisecmd " raisedata $c $c2 "
if  { $::LINUXNOMATLAB != 1 } {$w.nb pageconfigure task_conf -raisecmd { raisetaskconf $c $c2 $c4 } 
} else { if ![file exists $env(TMPDIR)] { file mkdir $env(TMPDIR) }}

#
# Visualizzazione finale del tutto
#
        pack $w.nb -expand yes -fill both -padx 5 -pady 5 -side top



#vwait ::evento
#tk_messageBox -message "dopo forever"
#tk_messageBox -message "legopc.tix: argc=$argc argv=$argv"  


    #auto load attempt (if model name provided)
    if {$argc == 1} {
    set curFileName [file tail $argv]
    
#tk_messageBox -message "legopc.tix: curFileName=$curFileName" 
        aprimodello $c $c2 $f4 1

#    apri_modello $c $c2 1 
#    	topRead $c $argv
    	if {$curFileName == "untitled"} {
    		set messaggio "Model $argv not found! No model loaded..."
    		tk_messageBox -message $messaggio -type ok -icon error
          }
    } elseif {$argc != 0} {
    	set messaggio "Wrong number or arguments (is $argc: should be 0 or 1):\n"
    	append messaggio "(only the name of the active model may be provided)."
    	tk_messageBox -message $messaggio -type ok
    }

#puts "c=$c c2=$c2 c4=$c4"


# aggiungo menu per la ricerca dei blocchi
set ::canv1 $c
set ::canv2 $c2
set ::canv3 $c4
    .menu.view add command -label "Find name" -command trova_win 
##############

    
#vwait ::evento
#tk_messageBox -message "dopo forever"
#while {1} {
#	vwait needbuild
#	if {$needbuild == 0} {
#		$w.nb pageconfigure data_ass -state normal
#	} else {
#		$w.nb pageconfigure data_ass -state disabled
#	}
#}
#
set ::line_anim 0






