/*
   modulo outascii_allarline.pc
   tipo 
   release 1.3
   data 4/5/96
   reserved @(#)outascii_allarline.pc	1.3
*/
/*
        Variabile per identificazione della versione
*/
/*
        Fine sezione per SCCS
*/
#include <stdio.h>
#include <string.h>
#include <sqlca.h>
#include <db.h>
#include <editallarline.h>
#include <outascii.h>
#include <allarline.h>

int trimblanks(char *psz,int lung);
int scrivi_header(char * nome,STRUCT_TABLE *tab, int num);

int outascii_allarline()
{
ALLARLINE var;
int i,numero_record;
FILE *fp;
EXEC SQL declare allarline_cursor CURSOR FOR 
	select * FROM allarline;

printf("output ascii allarline\n");
memset(&var,0,sizeof(ALLARLINE));

EXEC SQL select count(*) into :numero_record from allarline;

scrivi_header("AllarLin",editallarline,NUM_CAMPI_EDITALLARLINE);
if(!(fp=fopen("AllarLin.txt","a+")))
{
	perror("AllarLin.txt");
	return(0);
}

EXEC SQL open allarline_cursor;
for(i=0;i<numero_record;i++)
{
	EXEC SQL fetch allarline_cursor 
		INTO :var;

	trimblanks(var.Device,DB_Tipo_AllarLine);

	fprintf(fp,"%d;",var.Indice);
	fprintf(fp,"\"%s\";",var.Device);
	fprintf(fp,"\"%c\";",var.baud);
	fprintf(fp,"\"%c\";",var.data);
	fprintf(fp,"\"%c\";",var.stop);
	if(var.parita == ' ')
		fprintf(fp,";\n",var.parita);
	else
		fprintf(fp,"%c;\n",var.parita);
}

fclose(fp);
return(1);
}

