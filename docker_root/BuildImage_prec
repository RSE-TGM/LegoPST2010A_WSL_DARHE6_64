#!/bin/bash

versione="aguagliardi/legopst:1.0"
PROCEED_AUTOMATICALLY=false

# Analizza i parametri della riga di comando
while [[ "$#" -gt 0 ]]; do
    case $1 in
        -y|--yes) PROCEED_AUTOMATICALLY=true; shift ;;
        *) echo "Parametro sconosciuto: $1"; exit 1 ;;
    esac
    # Non c'è bisogno di 'shift' qui se si gestisce un solo tipo di parametro
    # Se ci fossero altri parametri, 'shift' sarebbe necessario dopo ogni case
done

# Funzione per eseguire la build
build_image() {
    echo " "
    echo "Building dell'immagine $versione"
    set -x
    # Assicurati che il percorso per cd sia corretto rispetto alla posizione dello script
    # Se lo script è in LegoPST2010A_WSL_DARHE6_64/docker/, allora ../.. è corretto per andare alla root del progetto.
    # Altrimenti, aggiusta il percorso.
    cd ../.. 
    docker --debug build -t "$versione" --file LegoPST2010A_WSL_DARHE6_64/docker/Dockerfile_LegoPST .
    local build_status=$? # Salva lo stato di uscita del comando docker build
    set +x
    if [ $build_status -eq 0 ]; then
        echo "--------------> Fine building dell'immagine $versione <---------------"
    else
        echo "Errore nel building dell'immagine (exit code: $build_status)"
    fi
    return $build_status # Restituisce lo stato della build per eventuale uso futuro
}

if [ "$PROCEED_AUTOMATICALLY" = true ]; then
    echo "Opzione -y rilevata, procedo automaticamente con la build."
    build_image
else
    while true; do
        echo " "
        # Il messaggio di building viene spostato dentro la funzione build_image
        # per evitare duplicazioni, ma possiamo tenere la domanda qui.
        echo "Verrà costruita l'immagine Docker: $versione"
        read -p "Procedo? (y/n) " yn

        case $yn in
            [yY] )
                build_image
                break;;
            [nN] )
                echo "Operazione annullata dall'utente."
                exit 0;; # Uscita pulita se l'utente sceglie 'no'
            * )
                echo "Risposta non valida. Per favore, inserisci 'y' o 'n'.";;
        esac
    done
fi

# Opzionale: esci con lo stato della build se è stata eseguita automaticamente
if [ "$PROCEED_AUTOMATICALLY" = true ]; then
    # build_image ha già stampato il messaggio di successo/errore
    # Se vuoi che lo script esca con lo stato della build:
    # exit $? # Questo userebbe lo stato dell'ultimo comando (che potrebbe non essere build_image)
    # Meglio se build_image restituisce il suo stato e lo usi qui.
    # Dato che build_image è l'ultima cosa eseguita in quel branch, $? dovrebbe essere corretto.
    # Per maggiore chiarezza, se build_image restituisce lo stato:
    # build_image
    # script_exit_status=$?
    # exit $script_exit_status
    # Ma dato che build_image è l'ultima chiamata, un semplice 'exit $?'
    # dopo il blocco if "$PROCEED_AUTOMATICALLY" dovrebbe funzionare se vuoi propagare l'errore.
    # Altrimenti, se vuoi solo eseguire e non preoccuparti dello stato di uscita dello script
    # per l'automazione, puoi omettere un 'exit' esplicito qui.
    # L'attuale 'exit $build_status' all'interno di build_image non è corretto,
    # dovrebbe essere 'return $build_status'. Ho corretto sopra.
    # Lo script principale uscirà con lo stato dell'ultimo comando eseguito.
    # Se build_image è l'ultima cosa nel branch -y, il suo stato di ritorno sarà quello dello script.
    : # Nessuna azione aggiuntiva qui, lo script terminerà.
fi